<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/posts/e803.html"/>
      <url>/posts/e803.html</url>
      
        <content type="html"><![CDATA[<h2 id="叨叨"><a href="#叨叨" class="headerlink" title="叨叨"></a>叨叨</h2><p>数据结构与算法是程序员的基本功，无论学什么计算机语言，Java、PHP、或者是python等待，数据结构与算法都是必修课。只可惜，越是基本功的东西，越难学，就像高中的数学。<br>数据结构与算法分为数据结构和算法<br>    数据结构：数组、字符串、线性表、树、栈、堆、队列、图<br>    算法：排序、贪心、动态规划、回溯、分治、查找<br>这一篇笔记先整理下排序吧，光一个排序就有十个排序算法。越想越头秃。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。<br>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。</p><p><img src="img/sort.png" alt=""></p><p><img src="img/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt=""></p><h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p><p>线性对数阶 (O(nlog2n)) 排序 ：快速排序、堆排序和归并排序；</p><p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数： 希尔排序</p><p>线性阶 (O(n)) 排序 ：基数排序，桶、箱排序。</p><h2 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><p>n：数据规模<br>k：”桶”的个数<br>In-place：占用常数内存，不占用额外内存<br>Out-place：占用额外内存<br>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p><h2 id="链接直达："><a href="#链接直达：" class="headerlink" title="链接直达："></a>链接直达：</h2><p><a href="https://williscode.gitee.io/posts/c3e4.html">冒泡排序</a></p><p><a href="https://williscode.gitee.io/posts/5911.html">选择排序</a></p><p><a href="https://williscode.gitee.io/posts/551c.html">插入排序</a></p><p><a href="https://williscode.gitee.io/posts/75c9.html">希尔排序</a></p><p><a href="https://williscode.gitee.io/posts/69cd.html">归并排序</a></p><p><a href="https://williscode.gitee.io/posts/bd38.html">快速排序</a></p><p><a href="https://williscode.gitee.io/posts/b66a.html">堆排序</a></p><p><a href="https://williscode.gitee.io/posts/73fb.html">计数排序</a></p><p><a href="https://williscode.gitee.io/posts/4c8b.html">桶排序</a></p><p><a href="https://williscode.gitee.io/posts/2c9d.html">基数排序</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之基数排序</title>
      <link href="/posts/2c9d.html"/>
      <url>/posts/2c9d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h2><p>基数排序有两种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：<br>    基数排序：根据键值的每位数字来分配桶；<br>    计数排序：每个桶只存储单一键值；<br>    桶排序：每个桶存储一定范围的数值；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/radixSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) {    var mod = 10;    var dev = 1;    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {        for(var j = 0; j &lt; arr.length; j++) {            var bucket = parseInt((arr[j] % mod) / dev);            if(counter[bucket]==null) {                counter[bucket] = [];            }            counter[bucket].push(arr[j]);        }        var pos = 0;        for(var j = 0; j &lt; counter.length; j++) {            var value = null;            if(counter[j]!=null) {                while ((value = counter[j].shift()) != null) {                      arr[pos++] = value;                }          }        }    }    return arr;}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int maxDigit = getMaxDigit(arr);        return radixSort(arr, maxDigit);    }    /**     * 获取最高位数     */    private int getMaxDigit(int[] arr) {        int maxValue = getMaxValue(arr);        return getNumLenght(maxValue);    }    private int getMaxValue(int[] arr) {        int maxValue = arr[0];        for (int value : arr) {            if (maxValue &lt; value) {                maxValue = value;            }        }        return maxValue;    }    protected int getNumLenght(long num) {        if (num == 0) {            return 1;        }        int lenght = 0;        for (long temp = num; temp != 0; temp /= 10) {            lenght++;        }        return lenght;    }    private int[] radixSort(int[] arr, int maxDigit) {        int mod = 10;        int dev = 1;        for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)            int[][] counter = new int[mod * 2][0];            for (int j = 0; j &lt; arr.length; j++) {                int bucket = ((arr[j] % mod) / dev) + mod;                counter[bucket] = arrayAppend(counter[bucket], arr[j]);            }            int pos = 0;            for (int[] bucket : counter) {                for (int value : bucket) {                    arr[pos++] = value;                }            }        }        return arr;    }    /**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */    private int[] arrayAppend(int[] arr, int value) {        arr = Arrays.copyOf(arr, arr.length + 1);        arr[arr.length - 1] = value;        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function radixSort($arr, $maxDigit = null){    if ($maxDigit === null) {        $maxDigit = max($arr);    }    $counter = [];    for ($i = 0; $i &lt; $maxDigit; $i++) {        for ($j = 0; $j &lt; count($arr); $j++) {            preg_match_all(&#39;/\d/&#39;, (string) $arr[$j], $matches);            $numArr = $matches[0];            $lenTmp = count($numArr);            $bucket = array_key_exists($lenTmp - $i - 1, $numArr)                ? intval($numArr[$lenTmp - $i - 1])                : 0;            if (!array_key_exists($bucket, $counter)) {                $counter[$bucket] = [];            }            $counter[$bucket][] = $arr[$j];        }        $pos = 0;        for ($j = 0; $j &lt; count($counter); $j++) {            $value = null;            if ($counter[$j] !== null) {                while (($value = array_shift($counter[$j])) !== null) {                    $arr[$pos++] = $value;                }          }        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>int maxbit(int data[], int n) //辅助函数，求数据的最大位数{    int maxData = data[0];              ///&lt; 最大数    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。    for (int i = 1; i &lt; n; ++i)    {        if (maxData &lt; data[i])            maxData = data[i];    }    int d = 1;    int p = 10;    while (maxData &gt;= p)    {        //p *= 10; // Maybe overflow        maxData /= 10;        ++d;    }    return d;/*    int d = 1; //保存最大的位数    int p = 10;    for(int i = 0; i &lt; n; ++i)    {        while(data[i] &gt;= p)        {            p *= 10;            ++d;        }    }    return d;*/}void radixsort(int data[], int n) //基数排序{    int d = maxbit(data, n);    int *tmp = new int[n];    int *count = new int[10]; //计数器    int i, j, k;    int radix = 1;    for(i = 1; i &lt;= d; i++) //进行d次排序    {        for(j = 0; j &lt; 10; j++)            count[j] = 0; //每次分配前清空计数器        for(j = 0; j &lt; n; j++)        {            k = (data[j] / radix) % 10; //统计每个桶中的记录数            count[k]++;        }        for(j = 1; j &lt; 10; j++)            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶        for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中        {            k = (data[j] / radix) % 10;            tmp[count[k] - 1] = data[j];            count[k]--;        }        for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中            data[j] = tmp[j];        radix = radix * 10;    }    delete []tmp;    delete []count;}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><pre><code>#include&lt;stdio.h&gt;#define MAX 20//#define SHOWPASS#define BASE 10void print(int *a, int n) {  int i;  for (i = 0; i &lt; n; i++) {    printf(&quot;%d\t&quot;, a[i]);  }}void radixsort(int *a, int n) {  int i, b[MAX], m = a[0], exp = 1;  for (i = 1; i &lt; n; i++) {    if (a[i] &gt; m) {      m = a[i];    }  }  while (m / exp &gt; 0) {    int bucket[BASE] = { 0 };    for (i = 0; i &lt; n; i++) {      bucket[(a[i] / exp) % BASE]++;    }    for (i = 1; i &lt; BASE; i++) {      bucket[i] += bucket[i - 1];    }    for (i = n - 1; i &gt;= 0; i--) {      b[--bucket[(a[i] / exp) % BASE]] = a[i];    }    for (i = 0; i &lt; n; i++) {      a[i] = b[i];    }    exp *= BASE;#ifdef SHOWPASS    printf(&quot;\nPASS   : &quot;);    print(a, n);#endif  }}int main() {  int arr[MAX];  int i, n;  printf(&quot;Enter total elements (n &lt;= %d) : &quot;, MAX);  scanf(&quot;%d&quot;, &amp;n);  n = n &lt; MAX ? n : MAX;  printf(&quot;Enter %d Elements : &quot;, n);  for (i = 0; i &lt; n; i++) {    scanf(&quot;%d&quot;, &amp;arr[i]);  }  printf(&quot;\nARRAY  : &quot;);  print(&amp;arr[0], n);  radixsort(&amp;arr[0], n);  printf(&quot;\nSORTED : &quot;);  print(&amp;arr[0], n);  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/10.radixSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/10.radixSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/radix-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/radix-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之桶排序</title>
      <link href="/posts/4c8b.html"/>
      <url>/posts/4c8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<br>    1.在额外空间充足的情况下，尽量扩大桶的数量<br>    2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择多个比较排序算法对于性能的影响实质。</p><h2 id="最快与最慢"><a href="#最快与最慢" class="headerlink" title="最快与最慢"></a>最快与最慢</h2><p>最快：当输入的数据可以均匀地分配到每一个桶时。<br>最慢：当输入的数据被分配到了同一个桶时。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/Bucket_sort_1.svg_.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function bucketSort(arr, bucketSize) {    if (arr.length === 0) {      return arr;    }    var i;    var minValue = arr[0];    var maxValue = arr[0];    for (i = 1; i &lt; arr.length; i++) {      if (arr[i] &lt; minValue) {          minValue = arr[i];                // 输入数据的最小值      } else if (arr[i] &gt; maxValue) {          maxValue = arr[i];                // 输入数据的最大值      }    }    //桶的初始化    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;      var buckets = new Array(bucketCount);    for (i = 0; i &lt; buckets.length; i++) {        buckets[i] = [];    }    //利用映射函数将数据分配到各个桶中    for (i = 0; i &lt; arr.length; i++) {        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);    }    arr.length = 0;    for (i = 0; i &lt; buckets.length; i++) {        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序        for (var j = 0; j &lt; buckets[i].length; j++) {            arr.push(buckets[i][j]);                              }    }    return arr;}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class BucketSort implements IArraySort {    private static final InsertSort insertSort = new InsertSort();    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        return bucketSort(arr, 5);    }    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {        if (arr.length == 0) {            return arr;        }        int minValue = arr[0];        int maxValue = arr[0];        for (int value : arr) {            if (value &lt; minValue) {                minValue = value;            } else if (value &gt; maxValue) {                maxValue = value;            }        }        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;        int[][] buckets = new int[bucketCount][0];        // 利用映射函数将数据分配到各个桶中        for (int i = 0; i &lt; arr.length; i++) {            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);            buckets[index] = arrAppend(buckets[index], arr[i]);        }        int arrIndex = 0;        for (int[] bucket : buckets) {            if (bucket.length &lt;= 0) {                continue;            }            // 对每个桶进行排序，这里使用了插入排序            bucket = insertSort.sort(bucket);            for (int value : bucket) {                arr[arrIndex++] = value;            }        }        return arr;    }    /**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */    private int[] arrAppend(int[] arr, int value) {        arr = Arrays.copyOf(arr, arr.length + 1);        arr[arr.length - 1] = value;        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function bucketSort($arr, $bucketSize = 5){    if (count($arr) === 0) {      return $arr;    }    $minValue = $arr[0];    $maxValue = $arr[0];    for ($i = 1; $i &lt; count($arr); $i++) {      if ($arr[$i] &lt; $minValue) {          $minValue = $arr[$i];      } else if ($arr[$i] &gt; $maxValue) {          $maxValue = $arr[$i];      }    }    $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1;    $buckets = array();    for ($i = 0; $i &lt; count($buckets); $i++) {        $buckets[$i] = [];    }    for ($i = 0; $i &lt; count($arr); $i++) {        $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i];    }    $arr = array();    for ($i = 0; $i &lt; count($buckets); $i++) {        $bucketTmp = $buckets[$i];        sort($bucketTmp);        for ($j = 0; $j &lt; count($bucketTmp); $j++) {            $arr[] = $bucketTmp[$j];        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM = 10;struct ListNode{        explicit ListNode(int i=0):mData(i),mNext(NULL){}        ListNode* mNext;        int mData;};ListNode* insert(ListNode* head,int val){        ListNode dummyNode;        ListNode *newNode = new ListNode(val);        ListNode *pre,*curr;        dummyNode.mNext = head;        pre = &amp;dummyNode;        curr = head;        while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){                pre = curr;                curr = curr-&gt;mNext;        }        newNode-&gt;mNext = curr;        pre-&gt;mNext = newNode;        return dummyNode.mNext;}ListNode* Merge(ListNode *head1,ListNode *head2){        ListNode dummyNode;        ListNode *dummy = &amp;dummyNode;        while(NULL!=head1 &amp;&amp; NULL!=head2){                if(head1-&gt;mData &lt;= head2-&gt;mData){                        dummy-&gt;mNext = head1;                        head1 = head1-&gt;mNext;                }else{                        dummy-&gt;mNext = head2;                        head2 = head2-&gt;mNext;                }                dummy = dummy-&gt;mNext;        }        if(NULL!=head1) dummy-&gt;mNext = head1;        if(NULL!=head2) dummy-&gt;mNext = head2;        return dummyNode.mNext;}void BucketSort(int n,int arr[]){        vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));        for(int i=0;i&lt;n;++i){                int index = arr[i]/BUCKET_NUM;                ListNode *head = buckets.at(index);                buckets.at(index) = insert(head,arr[i]);        }        ListNode *head = buckets.at(0);        for(int i=1;i&lt;BUCKET_NUM;++i){                head = Merge(head,buckets.at(i));        }        for(int i=0;i&lt;n;++i){                arr[i] = head-&gt;mData;                head = head-&gt;mNext;        }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/9.bucketSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/9.bucketSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/bucket-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/bucket-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之计数排序</title>
      <link href="/posts/73fb.html"/>
      <url>/posts/73fb.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序的特征：<br>    当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.找出待排序的数组中最大和最小的元素<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/countingSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function countingSort(arr, maxValue) {    var bucket = new Array(maxValue+1),        sortedIndex = 0;        arrLen = arr.length,        bucketLen = maxValue + 1;    for (var i = 0; i &lt; arrLen; i++) {        if (!bucket[arr[i]]) {            bucket[arr[i]] = 0;        }        bucket[arr[i]]++;    }    for (var j = 0; j &lt; bucketLen; j++) {        while(bucket[j] &gt; 0) {            arr[sortedIndex++] = j;            bucket[j]--;        }    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def countingSort(arr, maxValue):    bucketLen = maxValue+1    bucket = [0]*bucketLen    sortedIndex =0    arrLen = len(arr)    for i in range(arrLen):        if not bucket[arr[i]]:            bucket[arr[i]]=0        bucket[arr[i]]+=1    for j in range(bucketLen):        while bucket[j]&gt;0:            arr[sortedIndex] = j            sortedIndex+=1            bucket[j]-=1    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func countingSort(arr []int, maxValue int) []int {        bucketLen := maxValue + 1        bucket := make([]int, bucketLen) // 初始为0的数组        sortedIndex := 0        length := len(arr)        for i := 0; i &lt; length; i++ {                bucket[arr[i]] += 1        }        for j := 0; j &lt; bucketLen; j++ {                for bucket[j] &gt; 0 {                        arr[sortedIndex] = j                        sortedIndex += 1                        bucket[j] -= 1                }        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class CountingSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int maxValue = getMaxValue(arr);        return countingSort(arr, maxValue);    }    private int[] countingSort(int[] arr, int maxValue) {        int bucketLen = maxValue + 1;        int[] bucket = new int[bucketLen];        for (int value : arr) {            bucket[value]++;        }        int sortedIndex = 0;        for (int j = 0; j &lt; bucketLen; j++) {            while (bucket[j] &gt; 0) {                arr[sortedIndex++] = j;                bucket[j]--;            }        }        return arr;    }    private int getMaxValue(int[] arr) {        int maxValue = arr[0];        for (int value : arr) {            if (maxValue &lt; value) {                maxValue = value;            }        }        return maxValue;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function countingSort($arr, $maxValue = null){    if ($maxValue === null) {        $maxValue = max($arr);    }    for ($m = 0; $m &lt; $maxValue + 1; $m++) {        $bucket[] = null;    }    $arrLen = count($arr);    for ($i = 0; $i &lt; $arrLen; $i++) {        if (!array_key_exists($arr[$i], $bucket)) {            $bucket[$arr[$i]] = 0;        }        $bucket[$arr[$i]]++;    }    $sortedIndex = 0;    foreach ($bucket as $key =&gt; $len) {        if ($len !== null) $arr[$sortedIndex++] = $key;    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;void print_arr(int *arr, int n) {        int i;        printf(&quot;%d&quot;, arr[0]);        for (i = 1; i &lt; n; i++)                printf(&quot; %d&quot;, arr[i]);        printf(&quot;\n&quot;);}void counting_sort(int *ini_arr, int *sorted_arr, int n) {        int *count_arr = (int *) malloc(sizeof(int) * 100);        int i, j, k;        for (k = 0; k &lt; 100; k++)                count_arr[k] = 0;        for (i = 0; i &lt; n; i++)                count_arr[ini_arr[i]]++;        for (k = 1; k &lt; 100; k++)                count_arr[k] += count_arr[k - 1];        for (j = n; j &gt; 0; j--)                sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];        free(count_arr);}int main(int argc, char **argv) {        int n = 10;        int i;        int *arr = (int *) malloc(sizeof(int) * n);        int *sorted_arr = (int *) malloc(sizeof(int) * n);        srand(time(0));        for (i = 0; i &lt; n; i++)                arr[i] = rand() % 100;        printf(&quot;ini_array: &quot;);        print_arr(arr, n);        counting_sort(arr, sorted_arr, n);        printf(&quot;sorted_array: &quot;);        print_arr(sorted_arr, n);        free(arr);        free(sorted_arr);        return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/counting-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/counting-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/posts/b66a.html"/>
      <url>/posts/b66a.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br>    1.大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>    2.小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.创建一个堆 H[0……n-1]；<br>2.把堆首（最大值）和堆尾互换；<br>3.把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>4.重复步骤 2，直到堆的尺寸为 1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/heapSort.gif" alt=""></p><p><img src="img/Sorting_heapsort_anim.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) {   // 建立大顶堆    len = arr.length;    for (var i = Math.floor(len/2); i &gt;= 0; i--) {        heapify(arr, i);    }}function heapify(arr, i) {     // 堆调整    var left = 2 * i + 1,        right = 2 * i + 2,        largest = i;    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {        largest = left;    }    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {        largest = right;    }    if (largest != i) {        swap(arr, i, largest);        heapify(arr, largest);    }}function swap(arr, i, j) {    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}function heapSort(arr) {    buildMaxHeap(arr);    for (var i = arr.length-1; i &gt; 0; i--) {        swap(arr, 0, i);        len--;        heapify(arr, 0);    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def buildMaxHeap(arr):    import math    for i in range(math.floor(len(arr)/2),-1,-1):        heapify(arr,i)def heapify(arr, i):    left = 2*i+1    right = 2*i+2    largest = i    if left &lt; arrLen and arr[left] &gt; arr[largest]:        largest = left    if right &lt; arrLen and arr[right] &gt; arr[largest]:        largest = right    if largest != i:        swap(arr, i, largest)        heapify(arr, largest)def swap(arr, i, j):    arr[i], arr[j] = arr[j], arr[i]def heapSort(arr):    global arrLen    arrLen = len(arr)    buildMaxHeap(arr)    for i in range(len(arr)-1,0,-1):        swap(arr,0,i)        arrLen -=1        heapify(arr, 0)    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func heapSort(arr []int) []int {        arrLen := len(arr)        buildMaxHeap(arr, arrLen)        for i := arrLen - 1; i &gt;= 0; i-- {                swap(arr, 0, i)                arrLen -= 1                heapify(arr, 0, arrLen)        }        return arr}func buildMaxHeap(arr []int, arrLen int) {        for i := arrLen / 2; i &gt;= 0; i-- {                heapify(arr, i, arrLen)        }}func heapify(arr []int, i, arrLen int) {        left := 2*i + 1        right := 2*i + 2        largest := i        if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {                largest = left        }        if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {                largest = right        }        if largest != i {                swap(arr, i, largest)                heapify(arr, largest, arrLen)        }}func swap(arr []int, i, j int) {        arr[i], arr[j] = arr[j], arr[i]}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class HeapSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int len = arr.length;        buildMaxHeap(arr, len);        for (int i = len - 1; i &gt; 0; i--) {            swap(arr, 0, i);            len--;            heapify(arr, 0, len);        }        return arr;    }    private void buildMaxHeap(int[] arr, int len) {        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {            heapify(arr, i, len);        }    }    private void heapify(int[] arr, int i, int len) {        int left = 2 * i + 1;        int right = 2 * i + 2;        int largest = i;        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {            largest = left;        }        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {            largest = right;        }        if (largest != i) {            swap(arr, i, largest);            heapify(arr, largest, len);        }    }    private void swap(int[] arr, int i, int j) {        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function buildMaxHeap(&amp;$arr){    global $len;    for ($i = floor($len/2); $i &gt;= 0; $i--) {        heapify($arr, $i);    }}function heapify(&amp;$arr, $i){    global $len;    $left = 2 * $i + 1;    $right = 2 * $i + 2;    $largest = $i;    if ($left &lt; $len &amp;&amp; $arr[$left] &gt; $arr[$largest]) {        $largest = $left;    }    if ($right &lt; $len &amp;&amp; $arr[$right] &gt; $arr[$largest]) {        $largest = $right;    }    if ($largest != $i) {        swap($arr, $i, $largest);        heapify($arr, $largest);    }}function swap(&amp;$arr, $i, $j){    $temp = $arr[$i];    $arr[$i] = $arr[$j];    $arr[$j] = $temp;}function heapSort($arr) {    global $len;    $len = count($arr);    buildMaxHeap($arr);    for ($i = count($arr) - 1; $i &gt; 0; $i--) {        swap($arr, 0, $i);        $len--;        heapify($arr, 0);    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a, int *b) {    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比較            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    int i;    // 初始化，i從最後一個父節點開始調整    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢    for (i = len - 1; i &gt; 0; i--) {        swap(&amp;arr[0], &amp;arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    int i;    for (i = 0; i &lt; len; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);    return 0;}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比較            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    // 初始化，i從最後一個父節點開始調整    for (int i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢    for (int i = len - 1; i &gt; 0; i--) {        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    for (int i = 0; i &lt; len; i++)        cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;    return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/7.heapSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/7.heapSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/heap-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/heap-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之快速排序</title>
      <link href="/posts/bd38.html"/>
      <url>/posts/bd38.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好<br>    快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。《算法艺术与信息学竞赛》</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.从数列中挑出一个元素，称为“基准”（privot）<br>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的可以任意一边）。在这个分区退出后，该基准就处于数列的中间位置。这个称为分区操作；<br>3.递归地把小于基准值元素地子数列和大于基准值元素的子数列排序；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/quickSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function quickSort(arr, left, right) {    var len = arr.length,        partitionIndex,        left = typeof left != &#39;number&#39; ? 0 : left,        right = typeof right != &#39;number&#39; ? len - 1 : right;    if (left &lt; right) {        partitionIndex = partition(arr, left, right);        quickSort(arr, left, partitionIndex-1);        quickSort(arr, partitionIndex+1, right);    }    return arr;}function partition(arr, left ,right) {     // 分区操作    var pivot = left,                      // 设定基准值（pivot）        index = pivot + 1;    for (var i = index; i &lt;= right; i++) {        if (arr[i] &lt; arr[pivot]) {            swap(arr, i, index);            index++;        }            }    swap(arr, pivot, index - 1);    return index-1;}function swap(arr, i, j) {    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}function partition2(arr, low, high) {  let pivot = arr[low];  while (low &lt; high) {    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {      --high;    }    arr[low] = arr[high];    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {      ++low;    }    arr[high] = arr[low];  }  arr[low] = pivot;  return low;}function quickSort2(arr, low, high) {  if (low &lt; high) {    let pivot = partition2(arr, low, high);    quickSort2(arr, low, pivot - 1);    quickSort2(arr, pivot + 1, high);  }  return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def quickSort(arr, left=None, right=None):    left = 0 if not isinstance(left,(int, float)) else left    right = len(arr)-1 if not isinstance(right,(int, float)) else right    if left &lt; right:        partitionIndex = partition(arr, left, right)        quickSort(arr, left, partitionIndex-1)        quickSort(arr, partitionIndex+1, right)    return arrdef partition(arr, left, right):    pivot = left    index = pivot+1    i = index    while  i &lt;= right:        if arr[i] &lt; arr[pivot]:            swap(arr, i, index)            index+=1        i+=1    swap(arr,pivot,index-1)    return index-1def swap(arr, i, j):    arr[i], arr[j] = arr[j], arr[i]</code></pre><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><pre><code>func quickSort(arr []int) []int {        return _quickSort(arr, 0, len(arr)-1)}func _quickSort(arr []int, left, right int) []int {        if left &lt; right {                partitionIndex := partition(arr, left, right)                _quickSort(arr, left, partitionIndex-1)                _quickSort(arr, partitionIndex+1, right)        }        return arr}func partition(arr []int, left, right int) int {        pivot := left        index := pivot + 1        for i := index; i &lt;= right; i++ {                if arr[i] &lt; arr[pivot] {                        swap(arr, i, index)                        index += 1                }        }        swap(arr, pivot, index-1)        return index - 1}func swap(arr []int, i, j int) {        arr[i], arr[j] = arr[j], arr[i]}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>//严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) {   int pivot = A[low];   while (low &lt; high) {     while (low &lt; high &amp;&amp; A[high] &gt;= pivot) {       --high;     }     A[low] = A[high];     while (low &lt; high &amp;&amp; A[low] &lt;= pivot) {       ++low;     }     A[high] = A[low];   }   A[low] = pivot;   return low; } void QuickSort(int A[], int low, int high) //快排母函数 {   if (low &lt; high) {     int pivot = Paritition1(A, low, high);     QuickSort(A, low, pivot - 1);     QuickSort(A, pivot + 1, high);   } }</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class QuickSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        return quickSort(arr, 0, arr.length - 1);    }    private int[] quickSort(int[] arr, int left, int right) {        if (left &lt; right) {            int partitionIndex = partition(arr, left, right);            quickSort(arr, left, partitionIndex - 1);            quickSort(arr, partitionIndex + 1, right);        }        return arr;    }    private int partition(int[] arr, int left, int right) {        // 设定基准值（pivot）        int pivot = left;        int index = pivot + 1;        for (int i = index; i &lt;= right; i++) {            if (arr[i] &lt; arr[pivot]) {                swap(arr, i, index);                index++;            }        }        swap(arr, pivot, index - 1);        return index - 1;    }    private void swap(int[] arr, int i, int j) {        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function quickSort($arr){    if (count($arr) &lt;= 1)        return $arr;    $middle = $arr[0];    $leftArray = array();    $rightArray = array();    for ($i = 1; $i &lt; count($arr); $i++) {        if ($arr[$i] &gt; $middle)            $rightArray[] = $arr[$i];        else            $leftArray[] = $arr[$i];    }    $leftArray = quickSort($leftArray);    $leftArray[] = $middle;    $rightArray = quickSort($rightArray);    return array_merge($leftArray, $rightArray);}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><pre><code>typedef struct _Range {    int start, end;} Range;Range new_Range(int s, int e) {    Range r;    r.start = s;    r.end = e;    return r;}void swap(int *x, int *y) {    int t = *x;    *x = *y;    *y = t;}void quick_sort(int arr[], const int len) {    if (len &lt;= 0)        return; // 避免len等於負值時引發段錯誤（Segment Fault）    // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素    Range r[len];    int p = 0;    r[p++] = new_Range(0, len - 1);    while (p) {        Range range = r[--p];        if (range.start &gt;= range.end)            continue;        int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點        int left = range.start, right = range.end;        do {            while (arr[left] &lt; mid) ++left;   // 檢測基準點左側是否符合要求            while (arr[right] &gt; mid) --right; //檢測基準點右側是否符合要求            if (left &lt;= right) {                swap(&amp;arr[left], &amp;arr[right]);                left++;                right--;               // 移動指針以繼續            }        } while (left &lt;= right);        if (range.start &lt; right) r[p++] = new_Range(range.start, right);        if (range.end &gt; left) r[p++] = new_Range(left, range.end);    }}</code></pre><p>递归版：</p><pre><code>void swap(int *x, int *y) {    int t = *x;    *x = *y;    *y = t;}void quick_sort_recursive(int arr[], int start, int end) {    if (start &gt;= end)        return;    int mid = arr[end];    int left = start, right = end - 1;    while (left &lt; right) {        while (arr[left] &lt; mid &amp;&amp; left &lt; right)            left++;        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)            right--;        swap(&amp;arr[left], &amp;arr[right]);    }    if (arr[left] &gt;= arr[end])        swap(&amp;arr[left], &amp;arr[end]);    else        left++;    if (left)        quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);}void quick_sort(int arr[], int len) {    quick_sort_recursive(arr, 0, len - 1);}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><p>函数版：</p><pre><code>sort(a,a + n);// 排序a[0]-a[n-1]的所有数.</code></pre><p>递归版：</p><pre><code>template &lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) {    if (start &gt;= end)        return;    T mid = arr[end];    int left = start, right = end - 1;    while (left &lt; right) { //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换        while (arr[left] &lt; mid &amp;&amp; left &lt; right) //试图在左侧找到一个比枢纽元更大的元素            left++;        while (arr[right] &gt;= mid &amp;&amp; left &lt; right) //试图在右侧找到一个比枢纽元更小的元素            right--;        std::swap(arr[left], arr[right]); //交换元素    }    if (arr[left] &gt;= arr[end])        std::swap(arr[left], arr[end]);    else        left++;    quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);}template &lt;typename T&gt; //整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能void quick_sort(T arr[], int len) {    quick_sort_recursive(arr, 0, len - 1);}</code></pre><p>迭代版：</p><pre><code>// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/struct Range {    int start, end;    Range(int s = 0, int e = 0) {        start = s, end = e;    }};template &lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能void quick_sort(T arr[], const int len) {    if (len &lt;= 0)        return; // 避免len等於負值時宣告堆疊陣列當機    // r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素    Range r[len];    int p = 0;    r[p++] = Range(0, len - 1);    while (p) {        Range range = r[--p];        if (range.start &gt;= range.end)            continue;        T mid = arr[range.end];        int left = range.start, right = range.end - 1;        while (left &lt; right) {            while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;            while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;            std::swap(arr[left], arr[right]);        }        if (arr[left] &gt;= arr[range.end])            std::swap(arr[left], arr[range.end]);        else            left++;        r[p++] = Range(range.start, left - 1);        r[p++] = Range(left + 1, range.end);    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</a></p><p><a href="https://www.runoob.com/w3cnote/quick-sort-2.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/quick-sort-2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之归并排序</title>
      <link href="/posts/69cd.html"/>
      <url>/posts/69cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。<br>该算法是采用分治法。<br>作为一种典型的分而治之的算法，归并排序的实现有两种方法：<br>    自上而下的递归（由于所有的递归方法都可以用迭代重写，所以还有第二种方法）<br>    自下而上的迭代；<br>PS：递归虽然有简洁的优点，但是也有显著的缺点：<br>    1.时间、空间方面：由于递归是函数调用自身，而函数调用是有时间和空间的消耗的，每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。<br>    2.效率方面：递归中很多计算都是重复的，从而性能带来很大的负面影响。递归的本质是把一个问题分解成两个或多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。<br>    3.调用栈溢出：递归每调用一次函数都需要为函数在内存栈中分配空间，而每一个进程的栈容量是有限的。当递归调用的层次太多时，就会超出栈的容量，从而导致调用栈溢出。如求 1+2+3+4+….+n的和，如果n为10，结果可以返回，但如果n为5000，那么得出来的结果就会出错。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后得序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择较小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤3直到某一指针达到序列尾；<br>5.将另一序列剩下的所有元素直接复制到合并序列列尾。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/mergeSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function mergeSort(arr) {  // 采用自上而下的递归方法    var len = arr.length;    if(len &lt; 2) {        return arr;    }    var middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));}function merge(left, right){    var result = [];    while (left.length &amp;&amp; right.length) {        if (left[0] &lt;= right[0]) {            result.push(left.shift());        } else {            result.push(right.shift());        }    }    while (left.length)        result.push(left.shift());    while (right.length)        result.push(right.shift());    return result;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def mergeSort(arr):    import math    if(len(arr)&lt;2):        return arr    middle = math.floor(len(arr)/2)    left, right = arr[0:middle], arr[middle:]    return merge(mergeSort(left), mergeSort(right))def merge(left,right):    result = []    while left and right:        if left[0] &lt;= right[0]:            result.append(left.pop(0))        else:            result.append(right.pop(0));    while left:        result.append(left.pop(0))    while right:        result.append(right.pop(0));    return result</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func mergeSort(arr []int) []int {        length := len(arr)        if length &lt; 2 {                return arr        }        middle := length / 2        left := arr[0:middle]        right := arr[middle:]        return merge(mergeSort(left), mergeSort(right))}func merge(left []int, right []int) []int {        var result []int        for len(left) != 0 &amp;&amp; len(right) != 0 {                if left[0] &lt;= right[0] {                        result = append(result, left[0])                        left = left[1:]                } else {                        result = append(result, right[0])                        right = right[1:]                }        }        for len(left) != 0 {                result = append(result, left[0])                left = left[1:]        }        for len(right) != 0 {                result = append(result, right[0])                right = right[1:]        }        return result}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class MergeSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        if (arr.length &lt; 2) {            return arr;        }        int middle = (int) Math.floor(arr.length / 2);        int[] left = Arrays.copyOfRange(arr, 0, middle);        int[] right = Arrays.copyOfRange(arr, middle, arr.length);        return merge(sort(left), sort(right));    }    protected int[] merge(int[] left, int[] right) {        int[] result = new int[left.length + right.length];        int i = 0;        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {            if (left[0] &lt;= right[0]) {                result[i++] = left[0];                left = Arrays.copyOfRange(left, 1, left.length);            } else {                result[i++] = right[0];                right = Arrays.copyOfRange(right, 1, right.length);            }        }        while (left.length &gt; 0) {            result[i++] = left[0];            left = Arrays.copyOfRange(left, 1, left.length);        }        while (right.length &gt; 0) {            result[i++] = right[0];            right = Arrays.copyOfRange(right, 1, right.length);        }        return result;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function mergeSort($arr){    $len = count($arr);    if ($len &lt; 2) {        return $arr;    }    $middle = floor($len / 2);    $left = array_slice($arr, 0, $middle);    $right = array_slice($arr, $middle);    return merge(mergeSort($left), mergeSort($right));}function merge($left, $right){    $result = [];    while (count($left) &gt; 0 &amp;&amp; count($right) &gt; 0) {        if ($left[0] &lt;= $right[0]) {            $result[] = array_shift($left);        } else {            $result[] = array_shift($right);        }    }    while (count($left))        $result[] = array_shift($left);    while (count($right))        $result[] = array_shift($right);    return $result;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>int min(int x, int y) {    return x &lt; y ? x : y;}void merge_sort(int arr[], int len) {    int *a = arr;    int *b = (int *) malloc(len * sizeof(int));    int seg, start;    for (seg = 1; seg &lt; len; seg += seg) {        for (start = 0; start &lt; len; start += seg * 2) {            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        int *temp = a;        a = b;        b = temp;    }    if (a != arr) {        int i;        for (i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    free(b);}</code></pre><p>递归版：</p><pre><code>void merge_sort_recursive(int arr[], int reg[], int start, int end) {    if (start &gt;= end)        return;    int len = end - start, mid = (len &gt;&gt; 1) + start;    int start1 = start, end1 = mid;    int start2 = mid + 1, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    int k = start;    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    while (start1 &lt;= end1)        reg[k++] = arr[start1++];    while (start2 &lt;= end2)        reg[k++] = arr[start2++];    for (k = start; k &lt;= end; k++)        arr[k] = reg[k];}void merge_sort(int arr[], const int len) {    int reg[len];    merge_sort_recursive(arr, reg, 0, len - 1);}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>迭代版：</p><pre><code>template&lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能void merge_sort(T arr[], int len) {    T *a = arr;    T *b = new T[len];    for (int seg = 1; seg &lt; len; seg += seg) {        for (int start = 0; start &lt; len; start += seg + seg) {            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        T *temp = a;        a = b;        b = temp;    }    if (a != arr) {        for (int i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    delete[] b;}</code></pre><p>递归版：</p><pre><code>void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) {    // preconditions:    // Array[front...mid] is sorted    // Array[mid+1 ... end] is sorted    // Copy Array[front ... mid] to LeftSubArray    // Copy Array[mid+1 ... end] to RightSubArray    vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);    vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);    int idxLeft = 0, idxRight = 0;    LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max());    RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max());    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]    for (int i = front; i &lt;= end; i++) {        if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) {            Array[i] = LeftSubArray[idxLeft];            idxLeft++;        } else {            Array[i] = RightSubArray[idxRight];            idxRight++;        }    }}void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) {    if (front &gt;= end)        return;    int mid = (front + end) / 2;    MergeSort(Array, front, mid);    MergeSort(Array, mid + 1, end);    Merge(Array, front, mid, end);}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><pre><code>public static List&lt;int&gt; sort(List&lt;int&gt; lst) {    if (lst.Count &lt;= 1)        return lst;    int mid = lst.Count / 2;    List&lt;int&gt; left = new List&lt;int&gt;();  // 定义左侧List    List&lt;int&gt; right = new List&lt;int&gt;(); // 定义右侧List    // 以下兩個循環把 lst 分為左右兩個 List    for (int i = 0; i &lt; mid; i++)        left.Add(lst[i]);    for (int j = mid; j &lt; lst.Count; j++)        right.Add(lst[j]);    left = sort(left);    right = sort(right);    return merge(left, right);}/// &lt;summary&gt;/// 合併兩個已經排好序的List/// &lt;/summary&gt;/// &lt;param name=&quot;left&quot;&gt;左側List&lt;/param&gt;/// &lt;param name=&quot;right&quot;&gt;右側List&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static List&lt;int&gt; merge(List&lt;int&gt; left, List&lt;int&gt; right) {    List&lt;int&gt; temp = new List&lt;int&gt;();    while (left.Count &gt; 0 &amp;&amp; right.Count &gt; 0) {        if (left[0] &lt;= right[0]) {            temp.Add(left[0]);            left.RemoveAt(0);        } else {            temp.Add(right[0]);            right.RemoveAt(0);        }    }    if (left.Count &gt; 0) {        for (int i = 0; i &lt; left.Count; i++)            temp.Add(left[i]);    }    if (right.Count &gt; 0) {        for (int i = 0; i &lt; right.Count; i++)            temp.Add(right[i]);    }    return temp;}</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><pre><code>def merge list  return list if list.size &lt; 2  pivot = list.size / 2  # Merge  lambda { |left, right|    final = []    until left.empty? or right.empty?      final &lt;&lt; if left.first &lt; right.first; left.shift else right.shift end    end    final + left + right  }.call merge(list[0...pivot]), merge(list[pivot..-1])end</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F</a></p><p><a href="https://www.runoob.com/w3cnote/merge-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/merge-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序之希尔排序</title>
      <link href="/posts/75c9.html"/>
      <url>/posts/75c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>希尔排序，也称为递减增量排序，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>    插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>    但插入排序一般来说是低效的，因为插入排序每一次只能将数据移动一位。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>选择一个增量序列t1，t2，t3…..,tk，其中ti&gt;tj，tk=1 ；<br>按增量序列个数k，对序列进行k趟排序；<br>每趟排序，根据对应的增量ti，将待排序分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function shellSort(arr) {    var len = arr.length,        temp,        gap = 1;    while(gap &lt; len/3) {          //动态定义间隔序列        gap =gap*3+1;    }    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {        for (var i = gap; i &lt; len; i++) {            temp = arr[i];            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {                arr[j+gap] = arr[j];            }            arr[j+gap] = temp;        }    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def shellSort(arr):    import math    gap=1    while(gap &lt; len(arr)/3):        gap = gap*3+1    while gap &gt; 0:        for i in range(gap,len(arr)):            temp = arr[i]            j = i-gap            while j &gt;=0 and arr[j] &gt; temp:                arr[j+gap]=arr[j]                j-=gap            arr[j+gap] = temp        gap = math.floor(gap/3)    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func shellSort(arr []int) []int {        length := len(arr)        gap := 1        for gap &lt; gap/3 {                gap = gap*3 + 1        }        for gap &gt; 0 {                for i := gap; i &lt; length; i++ {                        temp := arr[i]                        j := i - gap                        for j &gt;= 0 &amp;&amp; arr[j] &gt; temp {                                arr[j+gap] = arr[j]                                j -= gap                        }                        arr[j+gap] = temp                }                gap = gap / 3        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class ShellSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int gap = 1;        while (gap &lt; arr.length) {            gap = gap * 3 + 1;        }        while (gap &gt; 0) {            for (int i = gap; i &lt; arr.length; i++) {                int tmp = arr[i];                int j = i - gap;                while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {                    arr[j + gap] = arr[j];                    j -= gap;                }                arr[j + gap] = tmp;            }            gap = (int) Math.floor(gap / 3);        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function shellSort($arr){    $len = count($arr);    $temp = 0;    $gap = 1;    while($gap &lt; $len / 3) {        $gap = $gap * 3 + 1;    }    for ($gap; $gap &gt; 0; $gap = floor($gap / 3)) {        for ($i = $gap; $i &lt; $len; $i++) {            $temp = $arr[$i];            for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $temp; $j -= $gap) {                $arr[$j+$gap] = $arr[$j];            }            $arr[$j+$gap] = $temp;        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>void shell_sort(int arr[], int len) {        int gap, i, j;        int temp;        for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)                for (i = gap; i &lt; len; i++) {                        temp = arr[i];                        for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                                arr[j + gap] = arr[j];                        arr[j + gap] = temp;                }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>template&lt;typename T&gt;void shell_sort(T array[], int length) {    int h = 1;    while (h &lt; length / 3) {        h = 3 * h + 1;    }    while (h &gt;= 1) {        for (int i = h; i &lt; length; i++) {            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {                std::swap(array[j], array[j - h]);            }        }        h = h / 3;    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/4.shellSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/4.shellSort.md</a></p><p><a href="https://www.runoob.com/w3cnote/shell-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之插入排序</title>
      <link href="/posts/551c.html"/>
      <url>/posts/551c.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>插入排序是一种最简单直观的排序算法，工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序和冒泡排序一样，也有一种优化算法，叫折半插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>将第一排待排序序列第一个元素看作一个有序序列，把第二个元素到最后一个元素当作是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每一个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某一个元素相等，则将待插入元素插到相等元素的后面）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> preIndex<span class="token punctuation">,</span> current<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            preIndex<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">while</span> preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>            preIndex<span class="token operator">-=</span><span class="token number">1</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current    <span class="token keyword">return</span> arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func insertionSort(arr []int) []int {        for i := range arr {                preIndex := i - 1                current := arr[i]                for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {                        arr[preIndex+1] = arr[preIndex]                        preIndex -= 1                }                arr[preIndex+1] = current        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class InsertSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的        for (int i = 1; i &lt; arr.length; i++) {            // 记录要插入的数据            int tmp = arr[i];            // 从已经排序的序列最右边的开始比较，找到比其小的数            int j = i;            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {                arr[j] = arr[j - 1];                j--;            }            // 存在比其小的数，插入            if (j != i) {                arr[j] = tmp;            }        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function insertionSort($arr){    $len = count($arr);    for ($i = 1; $i &lt; $len; $i++) {        $preIndex = $i - 1;        $current = $arr[$i];        while($preIndex &gt;= 0 &amp;&amp; $arr[$preIndex] &gt; $current) {            $arr[$preIndex+1] = $arr[$preIndex];            $preIndex--;        }        $arr[$preIndex+1] = $current;    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>void insertion_sort(int arr[], int len){        int i,j,key;        for (i=1;i&lt;len;i++){                key = arr[i];                j=i-1;                while((j&gt;=0) &amp;&amp; (arr[j]&gt;key)) {                        arr[j+1] = arr[j];                        j--;                }                arr[j+1] = key;        }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>void insertion_sort(int arr[],int len){        for(int i=1;i&lt;len;i++){                int key=arr[i];                int j=i-1;                while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){                        arr[j+1]=arr[j];                        j--;                }                arr[j+1]=key;        }}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><pre><code>public static void InsertSort(int[] array){    for(int i = 1;i &lt; array.length;i++)    {        int temp = array[i];        for(int j = i - 1;j &gt;= 0;j--)        {            if(array[j] &gt; temp)            {                array[j + 1] = array[j];                array[j] = temp;            }            else                break;        }    }}</code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre><code>for i in 1..&lt;arr.endIndex {    let temp = arr[i]    for j in (0..&lt;i).reversed() {        if arr[j] &gt; temp {            arr.swapAt(j, j+1)        }    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/w3cnote/insertion-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/insertion-sort.html</a><br><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/3.insertionSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/3.insertionSort.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之选择排序</title>
      <link href="/posts/5911.html"/>
      <url>/posts/5911.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去，都是 O(n²)的时间复杂度。所以用到选择排序的时候，数据规模越小越好。</p><p>选择排序唯一的好处可能就是不占用额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>首先在未排序的序列中找到最小（大）的元素，存放在排序序列的起始位置。</p><p>再从剩余未排序的序列的中继续寻找最小（大）的元素，然后存放在已排序序列的末尾。</p><p>重复第二步操作，直到所有元素均排序完毕。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function selectionSort(arr) {    var len = arr.length;    var minIndex, temp;    for (var i = 0; i &lt; len - 1; i++) {        minIndex = i;        for (var j = i + 1; j &lt; len; j++) {            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数                minIndex = j;                 // 将最小数的索引保存            }        }        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    }    return arr;}</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code>def selectionSort(arr):    for i in range(len(arr) - 1):        # 记录最小数的索引        minIndex = i        for j in range(i + 1, len(arr)):            if arr[j] &lt; arr[minIndex]:                minIndex = j        # i 不是最小数时，将 i 和最小数进行交换        if i != minIndex:            arr[i], arr[minIndex] = arr[minIndex], arr[i]    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func selectionSort(arr []int) []int {        length := len(arr)        for i := 0; i &lt; length-1; i++ {                min := i                for j := i + 1; j &lt; length; j++ {                        if arr[min] &gt; arr[j] {                                min = j                        }                }                arr[i], arr[min] = arr[min], arr[i]        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class SelectionSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        // 总共要经过 N-1 轮比较        for (int i = 0; i &lt; arr.length - 1; i++) {            int min = i;            // 每轮需要比较的次数 N-i            for (int j = i + 1; j &lt; arr.length; j++) {                if (arr[j] &lt; arr[min]) {                    // 记录目前能找到的最小值元素的下标                    min = j;                }            }            // 将找到的最小值和i位置所在的值进行交换            if (i != min) {                int tmp = arr[i];                arr[i] = arr[min];                arr[min] = tmp;            }        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function selectionSort($arr){    $len = count($arr);    for ($i = 0; $i &lt; $len - 1; $i++) {        $minIndex = $i;        for ($j = $i + 1; $j &lt; $len; $j++) {            if ($arr[$j] &lt; $arr[$minIndex]) {                $minIndex = $j;            }        }        $temp = $arr[$i];        $arr[$i] = $arr[$minIndex];        $arr[$minIndex] = $temp;    }    return $arr;}</code></pre><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><pre><code>void swap(int *a,int *b) //交換兩個變數{    int temp = *a;    *a = *b;    *b = temp;}void selection_sort(int arr[], int len){    int i,j;        for (i = 0 ; i &lt; len - 1 ; i++)    {                int min = i;                for (j = i + 1; j &lt; len; j++)     //走訪未排序的元素                        if (arr[j] &lt; arr[min])    //找到目前最小值                                min = j;    //紀錄最小值                swap(&amp;arr[min], &amp;arr[i]);    //做交換        }}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>template&lt;typename T&gt; //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能void selection_sort(std::vector&lt;T&gt;&amp; arr) {        for (int i = 0; i &lt; arr.size() - 1; i++) {                int min = i;                for (int j = i + 1; j &lt; arr.size(); j++)                        if (arr[j] &lt; arr[min])                                min = j;                std::swap(arr[i], arr[min]);        }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><pre><code>static void selection_sort&lt;T&gt;(T[] arr) where T : System.IComparable&lt;T&gt;{//整數或浮點數皆可使用        int i, j, min, len = arr.Length;        T temp;        for (i = 0; i &lt; len - 1; i++) {                min = i;                for (j = i + 1; j &lt; len; j++)                        if (arr[min].CompareTo(arr[j]) &gt; 0)                                min = j;                temp = arr[min];                arr[min] = arr[i];                arr[i] = temp;        }}</code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre><code>import Foundation/// 选择排序////// - Parameter list: 需要排序的数组func selectionSort(_ list: inout [Int]) -&gt; Void {    for j in 0..&lt;list.count - 1 {        var minIndex = j        for i in j..&lt;list.count {            if list[minIndex] &gt; list[i] {                minIndex = i            }        }        list.swapAt(j, minIndex)    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/2.selectionSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/2.selectionSort.md</a><br><a href="https://www.runoob.com/w3cnote/selection-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/selection-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言初探—sizeof(数组名)与sizeof(*数组名)</title>
      <link href="/posts/197e.html"/>
      <url>/posts/197e.html</url>
      
        <content type="html"><![CDATA[<pre><code>#include&lt;stdio.h&gt;int main(){    int a[5]={1,2,3,4,5};    int len=(int)sizeof(a)/sizeof(*a);    printf(&quot;sizeof(数组名)=%d\n&quot;,sizeof(a));    printf(&quot;sizeof(*数组名)=%d\n&quot;,sizeof(*a));    printf(&quot;%d\n,len);    return 0;}</code></pre><p>运行结果：<br>sizeof(数组名)=20<br>sizeof(<em>数组名)=4<br>5<br>分析：<br>a为含有5个元素的数组，<br>数组名代表元素的首地址，所以sizeof(a)代表整个数组所占的内存空间，即5</em>4Byte=20Byte；<br><em>a表示指向首地址，即表示首地址的内容，所以sizeof(</em>a)表示首元素所占空间的大小。<br>(int)sizeof(a)/siezof(*a)表示的是数组a中所包含的元素个数。</p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之冒泡排序</title>
      <link href="/posts/c3e4.html"/>
      <url>/posts/c3e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地访问要排序地数列，一次比较两个元素，如果两个元素的排序顺序错误，就把他们交换过来。直到数列的排序顺序正确后就停止走访。这个算法的名字的由来是因为越小的元素会经过交换而慢慢浮到数列的顶端。</p><h2 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h2><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这一步操作做完后，最后的元素就会是最大的数。<br>针对所有的元素重复上述步骤，除了最后一个元素。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><p><img src="F:%5Cblog2%5Csource%5Cimg%5CbubbleSort.gif" alt=""></p><h2 id="3-最快与最慢"><a href="#3-最快与最慢" class="headerlink" title="3.最快与最慢"></a>3.最快与最慢</h2><p>当输入的数据已经是正序时，排序速度最快。<br>当输入的数据是反序时，排序速度最慢。</p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 相邻元素两两对比</span>                <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 元素交换</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>        length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">70</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">func</span> <span class="token function">bubbleSort</span> <span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>arr<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>arr<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i <span class="token punctuation">{</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试调用</span><span class="token keyword">func</span> <span class="token function">testSort</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 生成随机数数组进行排序操作</span>    <span class="token keyword">var</span> list<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token number">_</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">99</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token function">arc4random_uniform</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>list<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>list<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md</a></p><p><img src="C:%5CUsers%5CWillis-zzx%5CPictures%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5Ca4a3280e72d249caa75234ed749daedd.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+hexo搭建个人博客(主题：yilia)</title>
      <link href="/posts/b2ba.html"/>
      <url>/posts/b2ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>总结一下这一次的博客搭建吧，把所有步骤都写下来。</p><p>hexo是一个静态网页博客，很容易上手，在本地端部署后，再git到GitHub上，其余的域名什么的都不用搭理，这个比之前的wordprss容易多了，wordpress是动态博客，比较难。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h2 id="1-安装Node-js和hexo框架"><a href="#1-安装Node-js和hexo框架" class="headerlink" title="1.安装Node.js和hexo框架"></a>1.安装Node.js和hexo框架</h2><p>在官网就可以下载，最好下载新版的。</p><p>打开终端命令行，我的是win10，用powershell，在vs code新建终端即可。</p><p>node -v #查看node版本</p><p>npm -v #查看npm版本</p><p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a> #安装淘宝的cnpm 管理器</p><p>cnpm -v #查看cnpm版本</p><p>ps:我没安装cnpm，安装这个一直不成功，直接用npm安装hexo也挺快的。</p><p>cnpm install -g hexo-cli #安装hexo框架</p><p>hexo -v #查看hexo版本</p><h2 id="2-创建博客"><a href="#2-创建博客" class="headerlink" title="2.创建博客"></a>2.创建博客</h2><p>mkdri blog #创建blog目录</p><p>cd blog #进入blog目录</p><p>hexo init #生成博客，初始化博客</p><p>hexo s #启动本地博客服务</p><p><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> #本地访问地址</p><p>hexo n “我的第一篇文章” #创建新的文章</p><p>cd /.. #返回blog目录</p><p>hexo clean #清理</p><p>hexo g #生成</p><h2 id="3-构建GitHub仓库"><a href="#3-构建GitHub仓库" class="headerlink" title="3.构建GitHub仓库"></a>3.构建GitHub仓库</h2><p>在自己的GitHub账号中创建一个仓库YourGithubName.github.io</p><p>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><p>#配置blog根目录下的_config.yaml文件</p><p>deploy:<br>  type: git<br>  repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>  branch: master</p><p>hexo d #部署到Github仓库里</p><p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>返回blog目录</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo clean #清理</p><p>hexo g #生成</p><p>hexo d #部署到远端GitHub仓库</p><p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #查看博客</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
