<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java hashCode()和equals()的若干问题</title>
      <link href="/posts/c465.html"/>
      <url>/posts/c465.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文章的内容主要解决以下几个问题："><a href="#本文章的内容主要解决以下几个问题：" class="headerlink" title="本文章的内容主要解决以下几个问题："></a>本文章的内容主要解决以下几个问题：</h1><ol><li>equals()的作用是什么？</li><li>equals()与==的区别是什么</li><li>hashCode()的作用是什么</li><li>hashCode()和equals()之间有什么联系</li></ol><h1 id="第一部分equals-的作用"><a href="#第一部分equals-的作用" class="headerlink" title="第一部分equals()的作用"></a>第一部分equals()的作用</h1><p>equals()的作用是判断两个对象是否相等</p><p>equals()定义在JDK的Object.java中。</p><p>通过判断两个对象的地址是否相等（即：是否为同一个对象）来区分他们是否相等。</p><p>源码如下：</p><p><code>public bollean equals(Obejct obj){</code></p><p><code>return (this == object;)</code></p><p><code>}</code></p><p>因为Object类是所有类的父类，所以既然Obejct.javva中定义了equals()方法，这就意味着所有的Java类都实现了equals()方法，所有的类都可以直接通过equals()方法去比较两个对象是否相等。但是，如果使用默认的equals()方法，等价于“==”方法。因此，通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则返回false。</p><p>根据“类是否覆盖equals()方法”，将其分为两类：</p><ol><li>若某个类没有覆盖equals()方法，当他通过equals()来比较两个对象时，实际上是比较两个对象是否为同一个对象。这个时候，equals()的作用等价于“==”。</li></ol><ol start="2"><li>可以通过覆盖类的equals()方法，让equals()通过其它方式来比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true，否则返回false。</li></ol><p>总结：没有覆盖，比较的是内存地址是否相等，有覆盖，比较的是内容是否相等。</p><p>Java对equals()的要求有如下几点：</p><ol><li><p>对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。</p></li><li><p>反射性：x.equals(x)必须返回是”true”。</p></li><li><p>类推性：如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。</p></li><li><p>一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。</p></li><li><p>非空性，x.equals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。</p></li></ol><h1 id="第二部分equals-与-的区别是什么"><a href="#第二部分equals-与-的区别是什么" class="headerlink" title="第二部分equals()与==的区别是什么"></a>第二部分equals()与==的区别是什么</h1><p>== ：作用是判断两个对象的地址是否相等，即判断两个对象是不是同一个对象。</p><p>equals()：作用也是判断两个对象是否相等，但是要分情况，有两种情况：</p><p>​        情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</p><p>​        情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</p><h1 id="第三部分-hashCode-的作用"><a href="#第三部分-hashCode-的作用" class="headerlink" title="第三部分 hashCode()的作用"></a>第三部分 hashCode()的作用</h1><p>hashCode()的作用是获取哈希码，也称为散列码。它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p>hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>虽然每一个Java类都包含hashCode()函数，但是，仅仅当创建某个“类的散列表”时，该类的hashCode()才有作用（作用是：确定该类的每一对象在散列表中的位置），其他情况下（如：创建类的单个对象，或者创建类的对象数组等），类的hashCode()是没有作用的。</p><p>散列表：Java集合中本质是散列表的类，如：HashMap、Hashtable、HashSet</p><p>总结：hashCode()在散列表才有用，在其他的地方毫无用武之地。在散列表中，其作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h1 id="第四部分-hashCode-和equals-的关系"><a href="#第四部分-hashCode-和equals-的关系" class="headerlink" title="第四部分 hashCode()和equals()的关系"></a>第四部分 hashCode()和equals()的关系</h1><ol><li><p>第一种 不会创建“类对应的散列表”</p><p>“不会创建类对应的散列表“指的是：不会在HashSet、Hashtable、HashMap等等本质是散列表的数据结构中用到该类。例如：不会创建该类的HashMap集合。</p><p>在这种情况下，该类的”hashCode()和equals()“是没有关系的，equals()用来比较该类的两个对象是否相等，而hashCode()没有任何作用。</p></li><li><p>第二种 会创建“类对应的散列表”</p><p>”会创建类对应的散列表“指的是：会在HashSet、Hashtable、HashMap等等本质是散列表的数据结构中用到该类。例如：会创建该类的HashMap集合</p><p>在这种情况下，该类的”hasnCode()和equals()“是有关系的：</p><ul><li>如果两个对象相等，那么他们的hashCode()值一定相同。这里的相等指的是：通过equals()比较两个对象时返回true。</li><li>如果两个对象hashCode()相等，它们并不一定相等。在散列表中，hashCode()相等，即两个键值对的哈希值相等，但是哈希值相等，并不一定能够得出键值对相等。（两个不同的键值对，哈希值相等，这是哈希冲突）<br>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/posts/1b99.html"/>
      <url>/posts/1b99.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建仓库-初始化-提交操作"><a href="#创建仓库-初始化-提交操作" class="headerlink" title="创建仓库/初始化/提交操作"></a>创建仓库/初始化/提交操作</h2><h3 id="1、初始化仓库操作，这样才可以用git进行代码管理"><a href="#1、初始化仓库操作，这样才可以用git进行代码管理" class="headerlink" title="1、初始化仓库操作，这样才可以用git进行代码管理"></a>1、初始化仓库操作，这样才可以用git进行代码管理</h3><p><code>git init</code></p><h3 id="2、git-clone仓库地址"><a href="#2、git-clone仓库地址" class="headerlink" title="2、git clone仓库地址"></a>2、git clone仓库地址</h3><p>复制远程仓库的代码到本地。</p><p><code>git clone + &quot;仓库地址&quot;</code></p><h3 id="3、git-add-XXX"><a href="#3、git-add-XXX" class="headerlink" title="3、git add XXX"></a>3、git add XXX</h3><p>添加本地的某一个新文件到本地仓库，此时只是提交到本地仓库，并没有提交到远程仓库。</p><h3 id="4、git-add"><a href="#4、git-add" class="headerlink" title="4、git add"></a>4、git add</h3><p>这个命令和上面的区别在于，这个命令会添加所有的新文件，也就是当前目录下的所有新文件。</p><h3 id="5、git-commit-m-‘message’"><a href="#5、git-commit-m-‘message’" class="headerlink" title="5、git commit -m ‘message’"></a>5、git commit -m ‘message’</h3><p>提交代码到本地仓库，并没有到远程仓库。</p><h3 id="6、git-commit-am-‘message’"><a href="#6、git-commit-am-‘message’" class="headerlink" title="6、git commit -am ‘message’"></a>6、git commit -am ‘message’</h3><p>这个命令将第四、五条命令的步骤add和commit合二为一。</p><h2 id="日志查看-信息显示"><a href="#日志查看-信息显示" class="headerlink" title="日志查看/信息显示"></a>日志查看/信息显示</h2><h3 id="1、git-log"><a href="#1、git-log" class="headerlink" title="1、git log"></a>1、git log</h3><p>主要用于查看提交日志。</p><h3 id="2、git-status"><a href="#2、git-status" class="headerlink" title="2、git status"></a>2、git status</h3><p>可以用来查看仓库的状态。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="1、创建分支-git-branch-XXX"><a href="#1、创建分支-git-branch-XXX" class="headerlink" title="1、创建分支 git branch XXX"></a>1、创建分支 git branch XXX</h3><p>可以再远程界面创建分支，或者使用命令git branch xxx</p><p>也可以用git branch 查看分支</p><h3 id="2、切换分支-git-checkout-XXX"><a href="#2、切换分支-git-checkout-XXX" class="headerlink" title="2、切换分支 git checkout XXX"></a>2、切换分支 git checkout XXX</h3><p>切还分支：git checkout xxx，这样就切换到XXX分支了，接着可以到XXX分支进行功能开发工作</p><h3 id="3、创建分支并且切换分支-git-checkout-b-XXX"><a href="#3、创建分支并且切换分支-git-checkout-b-XXX" class="headerlink" title="3、创建分支并且切换分支 git checkout -b XXX"></a>3、创建分支并且切换分支 git checkout -b XXX</h3><p>git checkout -b xxx是同时执行了命令1和2：git branch xxx和git checkout xxx，创建并且直接切换到xx分支</p><h3 id="4、查看处于哪个分支git-branch"><a href="#4、查看处于哪个分支git-branch" class="headerlink" title="4、查看处于哪个分支git branch"></a>4、查看处于哪个分支git branch</h3><p>命令：git branch 可以直接查看本地的所有分支，并且当前处于哪个分支</p><h3 id="5、查看本地和远程所有分支-git-branch-a"><a href="#5、查看本地和远程所有分支-git-branch-a" class="headerlink" title="5、查看本地和远程所有分支 git branch -a"></a>5、查看本地和远程所有分支 git branch -a</h3><p>git branch -a</p><h3 id="6、合并分支git-merge"><a href="#6、合并分支git-merge" class="headerlink" title="6、合并分支git merge"></a>6、合并分支git merge</h3><p>切换到master分支：git checkout master</p><p>合并xxx分支：git merge xxx</p><h3 id="7、删除本地分支-git-branch-D-xxx"><a href="#7、删除本地分支-git-branch-D-xxx" class="headerlink" title="7、删除本地分支 git branch -D xxx"></a>7、删除本地分支 git branch -D xxx</h3><p>当完成功能开发后，并且合并到了master的时候，可以删除我们当前的分支，使用命令：git branch -D XXX</p><p>PS:若当前处于XXX分支，XXX分支是不能被删除的，需要先切换到其他的分支。</p><h3 id="8、删除远程分支-git-push-origin-–delete-XXX"><a href="#8、删除远程分支-git-push-origin-–delete-XXX" class="headerlink" title="8、删除远程分支 git push origin –delete XXX"></a>8、删除远程分支 git push origin –delete XXX</h3><p>删除远程分支属于危险操作，如果权限不合理，可能会出现大问题。</p><p>建议：git branch -a 查看所有分支，再进行操作。</p><h2 id="更新管理"><a href="#更新管理" class="headerlink" title="更新管理"></a>更新管理</h2><h3 id="1、提交代码到远程-git-push-origin-xxx"><a href="#1、提交代码到远程-git-push-origin-xxx" class="headerlink" title="1、提交代码到远程 git push origin xxx"></a>1、提交代码到远程 git push origin xxx</h3><p>本地代码写完后，提交到远程，最常用的操作，xxx是远程仓库的名称</p><p>最常用：git push origin master 添加到master。</p><h3 id="2、拉取远程代码到本地-git-pull-origin-xxx"><a href="#2、拉取远程代码到本地-git-pull-origin-xxx" class="headerlink" title="2、拉取远程代码到本地 git pull origin xxx"></a>2、拉取远程代码到本地 git pull origin xxx</h3><p>将远程代码下拉到本地并进行合并，等价于fetch和merge两步一起执行</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><h3 id="1、git-reset-–hard-xxx"><a href="#1、git-reset-–hard-xxx" class="headerlink" title="1、git reset –hard xxx"></a>1、git reset –hard xxx</h3><p>这个命令使用时需注意，会把当前分支的代码全部回退到以前的一个版本，不可逆转，使用需谨慎！</p><p>可以使用git reflog，查看所有的head的记录</p><p>参考连接：<a href="https://blog.csdn.net/YJG7D314/article/details/104551896" target="_blank" rel="noopener">git使用教程</a></p><p>​                    <a href="https://blog.csdn.net/qq_38111015/article/details/84885809" target="_blank" rel="noopener">git常用命令大全</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程和并发编程</title>
      <link href="/posts/a429.html"/>
      <url>/posts/a429.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多进程"><a href="#1-多进程" class="headerlink" title="1.多进程"></a>1.多进程</h2><h3 id="1-1多进程概念"><a href="#1-1多进程概念" class="headerlink" title="1.1多进程概念"></a>1.1多进程概念</h3><p>1.当前的操作系统都是多任务OS（OS是操作系统的简称）<br>2.每个独立执行的任务就是一个进程<br>3.OS将时间划分为多个时间片（时间很短）<br>4.每个时间片内将CPU分配某一个任务，时间片结束，CPU将自动回收，再分配给其他任务。从外部看，所有任 务是同时在执行。但是在CPU上，任务是按照串行依次运行（单核CPU）。如果是多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行。</p><h3 id="1-2多进程优点"><a href="#1-2多进程优点" class="headerlink" title="1.2多进程优点"></a>1.2多进程优点</h3><p>1.可以同时运行多个任务；<br>2.程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务；<br>3.当系统有多个CPU时，可以为多个程序同时服务；<br>    我们的CPU不再提高频率，而是提高核。<br>    2005年Herb Sutter的文章The free lunch is over，指明多核和并行程序才是 提高程序性能的唯一办法。</p><h3 id="1-3多进程的缺点"><a href="#1-3多进程的缺点" class="headerlink" title="1.3多进程的缺点"></a>1.3多进程的缺点</h3><p>太笨重，不好切换和管理。</p><h2 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h2><h3 id="2-1多线程概念"><a href="#2-1多线程概念" class="headerlink" title="2.1多线程概念"></a>2.1多线程概念</h3><p>1.一个程序可以包括多个子任务，可串/并行<br>2.每个子任务可以称为一个线程<br>3.如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是被调度到别的程序(进程)去。这样，提高本程序所获得CPU时间和利用率。</p><h3 id="2-2多线程创建"><a href="#2-2多线程创建" class="headerlink" title="2.2多线程创建"></a>2.2多线程创建</h3><p> java.lang.Thread –线程继承Thread类，实现run方法<br> java.lang.Runnable接口 –线程实现Runnable接口，实现run方法</p><pre><code>public class Thread1 extends Thread{    public void run(){        System.out.println(&quot;hello&quot;);    }}</code></pre><pre><code>public class Thread2 implements Runnable{    public void run(){        System.out.println(&quot;hello&quot;);    }} </code></pre><h3 id="2-3Runnable-VS-Thread"><a href="#2-3Runnable-VS-Thread" class="headerlink" title="2.3Runnable VS Thread"></a>2.3Runnable VS Thread</h3><p>1.Thread占据了父类的名额，不如Runnable方便<br>2.Thread 类实现Runnable<br>3.Runnable启动时需要Thread类的支持<br>4.Runnable 更容易实现多线程中资源共享<br>结论：建议实现Runnable接口来完成多线程</p><h3 id="2-4多线程启动"><a href="#2-4多线程启动" class="headerlink" title="2.4多线程启动"></a>2.4多线程启动</h3><p>1.start方法，会自动以新进程调用run方法<br>2.直接调用run方法，将变成串行执行<br>3.同一个线程，多次start会报错，只执行第一次start方法<br>4.多个线程启动，其启动的先后顺序是随机的<br>5.线程无需关闭，只要其run方法执行结束后，自动关闭<br>6.main函数(线程)可能早于新线程结束，整个程序并不终止<br>7.整个程序终止是等所有的线程都终止(包括main函数线程)</p><h3 id="2-5多线程启动规则"><a href="#2-5多线程启动规则" class="headerlink" title="2.5多线程启动规则"></a>2.5多线程启动规则</h3><p>1.调用run方法，来启动run方法，将会是串行运行；<br>2.调用start方法，来启动run方法，将会是并行运行（多线程运行）；<br>可以这么理解，串行就是多进程，并行就是多线程。<br>3.main线程可能早于子线程结束；<br>4.main线程和子线程都结束了，整个程序才算结束；<br>5.实现Runnable的对象必须包装在Thread类里面，才可以启动；<br>6.不能直接堆Runnable的对象进行start方法；<br>7.一个线程对象不能多次start，多次start会报错；<br>8.多个线程对象都start后，哪个先执行，完全由JVM/操作系统来主导，程序员无法决定；</p><h2 id="3-多进程和多线程对比"><a href="#3-多进程和多线程对比" class="headerlink" title="3.多进程和多线程对比"></a>3.多进程和多线程对比</h2><p>1.线程数据共享<br>2.线程通讯更高效<br>3.线程更轻量级，更容易切换<br>4.多个线程更容易管理<br>ps：多进程就是多个Java.exe运行，多线程就是一个java.exe运行</p><h2 id="4-多线程共享变量"><a href="#4-多线程共享变量" class="headerlink" title="4.多线程共享变量"></a>4.多线程共享变量</h2><p>粗粒度：子线程与子线程之间、main线程之间缺乏交流<br>细粒度：线程之间有信息交流通讯<br>通过共享变量达到信息共享<br>    -static变量<br>    -同一个Runnable类的成员变量</p><h3 id="4-1static变量"><a href="#4-1static变量" class="headerlink" title="4.1static变量"></a>4.1static变量</h3><pre><code>public class ThreadDemo0{    public static void main(String [] args)    {        new TestThread0().start();        new TestThread0().start();        new TestThread0().start();        new TestThread0().start();    }}class TestThread0 extends Thread  {    //private int tickets=100;           //每个线程卖100张，没有共享    private static int tickets=100;  //static变量是共享的，所有的线程共享    public void run()    {        while(true)        {            if(tickets&gt;0)            {                System.out.println(Thread.currentThread().getName() +                &quot; is selling ticket &quot; + tickets);                tickets = tickets - 1;            }            else            {                break;            }        }    }}//static变量共享消息，不是很准确，会有重复的现象。</code></pre><h3 id="4-2同一个Runnable类的成员变量"><a href="#4-2同一个Runnable类的成员变量" class="headerlink" title="4.2同一个Runnable类的成员变量"></a>4.2同一个Runnable类的成员变量</h3><pre><code>public class ThreadDemo1{    public static void main(String [] args)    {        TestThread1 t=new TestThread1();        new Thread(t).start();        new Thread(t).start();        new Thread(t).start();        new Thread(t).start();    }}class TestThread1 implements Runnable{    private int tickets=100;    public void run()    {        while(true)        {            if(tickets&gt;0)            {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                tickets--;                System.out.println(Thread.currentThread().getName() +&quot; is selling ticket &quot; + tickets);            }            else            {                break;            }        }    }}</code></pre><h3 id="4-3多线程信息共享问题"><a href="#4-3多线程信息共享问题" class="headerlink" title="4.3多线程信息共享问题"></a>4.3多线程信息共享问题</h3><p>-工作缓存副本<br>-关键步骤缺乏加锁限制<br>    举例：<br>    i++，并非原子性操作<br>        -读取主存i(正本)到工作缓存(副本)中<br>        -每个CPU执行(副本)i+1操作<br>        -CPU将结果写入到缓存(副本)中<br>        -数据从工作缓存(副本)刷到主存(正本)中<br>PS：线程只依赖工作缓存。</p><h3 id="4-4变量副本问题的解决方法"><a href="#4-4变量副本问题的解决方法" class="headerlink" title="4.4变量副本问题的解决方法"></a>4.4变量副本问题的解决方法</h3><p>-采用volatile 关键字修饰变量，保证不同线程对共享变量操作时的可见性。</p><pre><code>public class ThreadDemo2{    public static void main(String args[]) throws Exception    {        TestThread2 t = new TestThread2();        t.start();        Thread.sleep(2000);        t.flag = false;        System.out.println(&quot;main thread is exiting&quot;);    }}class TestThread2 extends Thread{    //boolean flag = true;   //子线程不会停止    volatile boolean flag = true;  //用volatile修饰的变量可以及时在各线程里面通知    public void run()    {        int i=0;        while(flag)        {            i++;        }        System.out.println(&quot;test thread3 is exiting&quot;);    }    } </code></pre><p>-关键步骤加锁限制<br>    -互斥：某一个线程运行一个代码段(关键区)，其他线程不能同时 运行这个代码段<br>    –同步：多个线程的运行，必须按照某一种规定的先后顺序来运行<br>    –互斥是同步的一种特例<br>    互斥的关键字是synchronized –synchronized代码块/函数，只能一个线程进入，虽然synchronized加大性能负担，但是使用简便。</p><pre><code>public class ThreadDemo3 {    public static void main(String[] args) {        TestThread3 t = new TestThread3();        new Thread(t, &quot;Thread-0&quot;).start();        new Thread(t, &quot;Thread-1&quot;).start();        new Thread(t, &quot;Thread-2&quot;).start();        new Thread(t, &quot;Thread-3&quot;).start();    }}class TestThread3 implements Runnable {    private volatile int tickets = 100; // 多个线程在共享的    String str = new String(&quot;&quot;);    public void run() {        while (true) {            sale();            try {                Thread.sleep(100);            } catch (Exception e) {                System.out.println(e.getMessage());            }            if (tickets &lt;= 0) {                break;            }        }    }    public synchronized void sale() { // 同步函数        if (tickets &gt; 0) {            System.out.println(Thread.currentThread().getName() + &quot; is saling ticket &quot; + tickets--);        }    }}</code></pre><h2 id="5-多线程管理"><a href="#5-多线程管理" class="headerlink" title="5.多线程管理"></a>5.多线程管理</h2><h3 id="5-1线程状态"><a href="#5-1线程状态" class="headerlink" title="5.1线程状态"></a>5.1线程状态</h3><p>-NEW 刚创建（new）<br>-RUNNABLE 就绪态（start）<br>-RUNNING 运行中（run）<br>-BLOCK 阻塞（sleep）<br>-TERMINATED 结束</p><p><img src="C:/Users/Willis-zzx/AppData/Roaming/Typora/typora-user-images/image-20200518095740006.png" alt="image-20200518095740006"></p><h3 id="5-2管理方法"><a href="#5-2管理方法" class="headerlink" title="5.2管理方法"></a>5.2管理方法</h3><p>1.Thread的部分API已经废弃<br>-暂停和恢复suspend/resume<br>-消亡stop/destroy<br>2.线程阻塞/和唤醒<br>-sleep，时间一到，自己会醒来<br>wait/notify/notifyAll，等待，需要别人来唤醒<br>–join，等待另外一个线程结束<br>–interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发InterruptedException(可解除阻塞)，并进行下一步处理。interrupt()是Thread类的方法，用来测试当前线程是否收到一个interrupt的信号，如果收到，该方法返回true，否则返回false。</p><h3 id="5-3主动与被动"><a href="#5-3主动与被动" class="headerlink" title="5.3主动与被动"></a>5.3主动与被动</h3><p>线程被动地暂停和终止：依靠别的线程来拯救自己，没有及时释放资源；<br>线程主动地暂停和终止：可以定期监测共享变量，如果需要暂停或终止，先释放资源再主动动作。<br>暂停：Thread.sleep()，休眠。<br>终止：run方法结束，线程终止。</p><h3 id="5-4多线程死锁"><a href="#5-4多线程死锁" class="headerlink" title="5.4多线程死锁"></a>5.4多线程死锁</h3><p>每一个线程互相持有别人需要的锁（哲学家吃面问题）<br>预防死锁，对资源进行等级排序。</p><h3 id="5-5守护（后台）进程"><a href="#5-5守护（后台）进程" class="headerlink" title="5.5守护（后台）进程"></a>5.5守护（后台）进程</h3><p>普通线程的结束，是run方法进行结束<br>守护线程的结束，是run方法运行结束或main函数结束<br>PS：守护线程永远不要访问资源，如文件或数据库等，因为守护线程结束时会来不及释放资源。</p><h3 id="5-6线程查看工具"><a href="#5-6线程查看工具" class="headerlink" title="5.6线程查看工具"></a>5.6线程查看工具</h3><p>线程查看工具 -jvisualvm</p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/posts/e803.html"/>
      <url>/posts/e803.html</url>
      
        <content type="html"><![CDATA[<h2 id="叨叨"><a href="#叨叨" class="headerlink" title="叨叨"></a>叨叨</h2><p>数据结构与算法是程序员的基本功，无论学什么计算机语言，Java、PHP、或者是python等待，数据结构与算法都是必修课。只可惜，越是基本功的东西，越难学，就像高中的数学。<br>数据结构与算法分为数据结构和算法<br>    数据结构：数组、字符串、线性表、树、栈、堆、队列、图<br>    算法：排序、贪心、动态规划、回溯、分治、查找<br>这一篇笔记先整理下排序吧，光一个排序就有十个排序算法。越想越头秃。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。<br>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。</p><p><img src="img/sort.png" alt=""></p><p><img src="img/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt=""></p><h2 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h2><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p><p>线性对数阶 (O(nlog2n)) 排序 ：快速排序、堆排序和归并排序；</p><p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数： 希尔排序</p><p>线性阶 (O(n)) 排序 ：基数排序，桶、箱排序。</p><h2 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><p>n：数据规模<br>k：”桶”的个数<br>In-place：占用常数内存，不占用额外内存<br>Out-place：占用额外内存<br>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p><h2 id="链接直达："><a href="#链接直达：" class="headerlink" title="链接直达："></a>链接直达：</h2><p><a href="https://williscode.gitee.io/posts/c3e4.html">冒泡排序</a></p><p><a href="https://williscode.gitee.io/posts/5911.html">选择排序</a></p><p><a href="https://williscode.gitee.io/posts/551c.html">插入排序</a></p><p><a href="https://williscode.gitee.io/posts/75c9.html">希尔排序</a></p><p><a href="https://williscode.gitee.io/posts/69cd.html">归并排序</a></p><p><a href="https://williscode.gitee.io/posts/bd38.html">快速排序</a></p><p><a href="https://williscode.gitee.io/posts/b66a.html">堆排序</a></p><p><a href="https://williscode.gitee.io/posts/73fb.html">计数排序</a></p><p><a href="https://williscode.gitee.io/posts/4c8b.html">桶排序</a></p><p><a href="https://williscode.gitee.io/posts/2c9d.html">基数排序</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之基数排序</title>
      <link href="/posts/2c9d.html"/>
      <url>/posts/2c9d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h2><p>基数排序有两种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：<br>    基数排序：根据键值的每位数字来分配桶；<br>    计数排序：每个桶只存储单一键值；<br>    桶排序：每个桶存储一定范围的数值；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/radixSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) {    var mod = 10;    var dev = 1;    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {        for(var j = 0; j &lt; arr.length; j++) {            var bucket = parseInt((arr[j] % mod) / dev);            if(counter[bucket]==null) {                counter[bucket] = [];            }            counter[bucket].push(arr[j]);        }        var pos = 0;        for(var j = 0; j &lt; counter.length; j++) {            var value = null;            if(counter[j]!=null) {                while ((value = counter[j].shift()) != null) {                      arr[pos++] = value;                }          }        }    }    return arr;}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int maxDigit = getMaxDigit(arr);        return radixSort(arr, maxDigit);    }    /**     * 获取最高位数     */    private int getMaxDigit(int[] arr) {        int maxValue = getMaxValue(arr);        return getNumLenght(maxValue);    }    private int getMaxValue(int[] arr) {        int maxValue = arr[0];        for (int value : arr) {            if (maxValue &lt; value) {                maxValue = value;            }        }        return maxValue;    }    protected int getNumLenght(long num) {        if (num == 0) {            return 1;        }        int lenght = 0;        for (long temp = num; temp != 0; temp /= 10) {            lenght++;        }        return lenght;    }    private int[] radixSort(int[] arr, int maxDigit) {        int mod = 10;        int dev = 1;        for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)            int[][] counter = new int[mod * 2][0];            for (int j = 0; j &lt; arr.length; j++) {                int bucket = ((arr[j] % mod) / dev) + mod;                counter[bucket] = arrayAppend(counter[bucket], arr[j]);            }            int pos = 0;            for (int[] bucket : counter) {                for (int value : bucket) {                    arr[pos++] = value;                }            }        }        return arr;    }    /**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */    private int[] arrayAppend(int[] arr, int value) {        arr = Arrays.copyOf(arr, arr.length + 1);        arr[arr.length - 1] = value;        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function radixSort($arr, $maxDigit = null){    if ($maxDigit === null) {        $maxDigit = max($arr);    }    $counter = [];    for ($i = 0; $i &lt; $maxDigit; $i++) {        for ($j = 0; $j &lt; count($arr); $j++) {            preg_match_all(&#39;/\d/&#39;, (string) $arr[$j], $matches);            $numArr = $matches[0];            $lenTmp = count($numArr);            $bucket = array_key_exists($lenTmp - $i - 1, $numArr)                ? intval($numArr[$lenTmp - $i - 1])                : 0;            if (!array_key_exists($bucket, $counter)) {                $counter[$bucket] = [];            }            $counter[$bucket][] = $arr[$j];        }        $pos = 0;        for ($j = 0; $j &lt; count($counter); $j++) {            $value = null;            if ($counter[$j] !== null) {                while (($value = array_shift($counter[$j])) !== null) {                    $arr[$pos++] = $value;                }          }        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>int maxbit(int data[], int n) //辅助函数，求数据的最大位数{    int maxData = data[0];              ///&lt; 最大数    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。    for (int i = 1; i &lt; n; ++i)    {        if (maxData &lt; data[i])            maxData = data[i];    }    int d = 1;    int p = 10;    while (maxData &gt;= p)    {        //p *= 10; // Maybe overflow        maxData /= 10;        ++d;    }    return d;/*    int d = 1; //保存最大的位数    int p = 10;    for(int i = 0; i &lt; n; ++i)    {        while(data[i] &gt;= p)        {            p *= 10;            ++d;        }    }    return d;*/}void radixsort(int data[], int n) //基数排序{    int d = maxbit(data, n);    int *tmp = new int[n];    int *count = new int[10]; //计数器    int i, j, k;    int radix = 1;    for(i = 1; i &lt;= d; i++) //进行d次排序    {        for(j = 0; j &lt; 10; j++)            count[j] = 0; //每次分配前清空计数器        for(j = 0; j &lt; n; j++)        {            k = (data[j] / radix) % 10; //统计每个桶中的记录数            count[k]++;        }        for(j = 1; j &lt; 10; j++)            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶        for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中        {            k = (data[j] / radix) % 10;            tmp[count[k] - 1] = data[j];            count[k]--;        }        for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中            data[j] = tmp[j];        radix = radix * 10;    }    delete []tmp;    delete []count;}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><pre><code>#include&lt;stdio.h&gt;#define MAX 20//#define SHOWPASS#define BASE 10void print(int *a, int n) {  int i;  for (i = 0; i &lt; n; i++) {    printf(&quot;%d\t&quot;, a[i]);  }}void radixsort(int *a, int n) {  int i, b[MAX], m = a[0], exp = 1;  for (i = 1; i &lt; n; i++) {    if (a[i] &gt; m) {      m = a[i];    }  }  while (m / exp &gt; 0) {    int bucket[BASE] = { 0 };    for (i = 0; i &lt; n; i++) {      bucket[(a[i] / exp) % BASE]++;    }    for (i = 1; i &lt; BASE; i++) {      bucket[i] += bucket[i - 1];    }    for (i = n - 1; i &gt;= 0; i--) {      b[--bucket[(a[i] / exp) % BASE]] = a[i];    }    for (i = 0; i &lt; n; i++) {      a[i] = b[i];    }    exp *= BASE;#ifdef SHOWPASS    printf(&quot;\nPASS   : &quot;);    print(a, n);#endif  }}int main() {  int arr[MAX];  int i, n;  printf(&quot;Enter total elements (n &lt;= %d) : &quot;, MAX);  scanf(&quot;%d&quot;, &amp;n);  n = n &lt; MAX ? n : MAX;  printf(&quot;Enter %d Elements : &quot;, n);  for (i = 0; i &lt; n; i++) {    scanf(&quot;%d&quot;, &amp;arr[i]);  }  printf(&quot;\nARRAY  : &quot;);  print(&amp;arr[0], n);  radixsort(&amp;arr[0], n);  printf(&quot;\nSORTED : &quot;);  print(&amp;arr[0], n);  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/10.radixSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/10.radixSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/radix-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/radix-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之桶排序</title>
      <link href="/posts/4c8b.html"/>
      <url>/posts/4c8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<br>    1.在额外空间充足的情况下，尽量扩大桶的数量<br>    2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br>同时，对于桶中元素的排序，选择多个比较排序算法对于性能的影响实质。</p><h2 id="最快与最慢"><a href="#最快与最慢" class="headerlink" title="最快与最慢"></a>最快与最慢</h2><p>最快：当输入的数据可以均匀地分配到每一个桶时。<br>最慢：当输入的数据被分配到了同一个桶时。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/Bucket_sort_1.svg_.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function bucketSort(arr, bucketSize) {    if (arr.length === 0) {      return arr;    }    var i;    var minValue = arr[0];    var maxValue = arr[0];    for (i = 1; i &lt; arr.length; i++) {      if (arr[i] &lt; minValue) {          minValue = arr[i];                // 输入数据的最小值      } else if (arr[i] &gt; maxValue) {          maxValue = arr[i];                // 输入数据的最大值      }    }    //桶的初始化    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;      var buckets = new Array(bucketCount);    for (i = 0; i &lt; buckets.length; i++) {        buckets[i] = [];    }    //利用映射函数将数据分配到各个桶中    for (i = 0; i &lt; arr.length; i++) {        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);    }    arr.length = 0;    for (i = 0; i &lt; buckets.length; i++) {        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序        for (var j = 0; j &lt; buckets[i].length; j++) {            arr.push(buckets[i][j]);                              }    }    return arr;}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class BucketSort implements IArraySort {    private static final InsertSort insertSort = new InsertSort();    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        return bucketSort(arr, 5);    }    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {        if (arr.length == 0) {            return arr;        }        int minValue = arr[0];        int maxValue = arr[0];        for (int value : arr) {            if (value &lt; minValue) {                minValue = value;            } else if (value &gt; maxValue) {                maxValue = value;            }        }        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;        int[][] buckets = new int[bucketCount][0];        // 利用映射函数将数据分配到各个桶中        for (int i = 0; i &lt; arr.length; i++) {            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);            buckets[index] = arrAppend(buckets[index], arr[i]);        }        int arrIndex = 0;        for (int[] bucket : buckets) {            if (bucket.length &lt;= 0) {                continue;            }            // 对每个桶进行排序，这里使用了插入排序            bucket = insertSort.sort(bucket);            for (int value : bucket) {                arr[arrIndex++] = value;            }        }        return arr;    }    /**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */    private int[] arrAppend(int[] arr, int value) {        arr = Arrays.copyOf(arr, arr.length + 1);        arr[arr.length - 1] = value;        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function bucketSort($arr, $bucketSize = 5){    if (count($arr) === 0) {      return $arr;    }    $minValue = $arr[0];    $maxValue = $arr[0];    for ($i = 1; $i &lt; count($arr); $i++) {      if ($arr[$i] &lt; $minValue) {          $minValue = $arr[$i];      } else if ($arr[$i] &gt; $maxValue) {          $maxValue = $arr[$i];      }    }    $bucketCount = floor(($maxValue - $minValue) / $bucketSize) + 1;    $buckets = array();    for ($i = 0; $i &lt; count($buckets); $i++) {        $buckets[$i] = [];    }    for ($i = 0; $i &lt; count($arr); $i++) {        $buckets[floor(($arr[$i] - $minValue) / $bucketSize)][] = $arr[$i];    }    $arr = array();    for ($i = 0; $i &lt; count($buckets); $i++) {        $bucketTmp = $buckets[$i];        sort($bucketTmp);        for ($j = 0; $j &lt; count($bucketTmp); $j++) {            $arr[] = $bucketTmp[$j];        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM = 10;struct ListNode{        explicit ListNode(int i=0):mData(i),mNext(NULL){}        ListNode* mNext;        int mData;};ListNode* insert(ListNode* head,int val){        ListNode dummyNode;        ListNode *newNode = new ListNode(val);        ListNode *pre,*curr;        dummyNode.mNext = head;        pre = &amp;dummyNode;        curr = head;        while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){                pre = curr;                curr = curr-&gt;mNext;        }        newNode-&gt;mNext = curr;        pre-&gt;mNext = newNode;        return dummyNode.mNext;}ListNode* Merge(ListNode *head1,ListNode *head2){        ListNode dummyNode;        ListNode *dummy = &amp;dummyNode;        while(NULL!=head1 &amp;&amp; NULL!=head2){                if(head1-&gt;mData &lt;= head2-&gt;mData){                        dummy-&gt;mNext = head1;                        head1 = head1-&gt;mNext;                }else{                        dummy-&gt;mNext = head2;                        head2 = head2-&gt;mNext;                }                dummy = dummy-&gt;mNext;        }        if(NULL!=head1) dummy-&gt;mNext = head1;        if(NULL!=head2) dummy-&gt;mNext = head2;        return dummyNode.mNext;}void BucketSort(int n,int arr[]){        vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));        for(int i=0;i&lt;n;++i){                int index = arr[i]/BUCKET_NUM;                ListNode *head = buckets.at(index);                buckets.at(index) = insert(head,arr[i]);        }        ListNode *head = buckets.at(0);        for(int i=1;i&lt;BUCKET_NUM;++i){                head = Merge(head,buckets.at(i));        }        for(int i=0;i&lt;n;++i){                arr[i] = head-&gt;mData;                head = head-&gt;mNext;        }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/9.bucketSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/9.bucketSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/bucket-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/bucket-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之计数排序</title>
      <link href="/posts/73fb.html"/>
      <url>/posts/73fb.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序的特征：<br>    当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.找出待排序的数组中最大和最小的元素<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/countingSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function countingSort(arr, maxValue) {    var bucket = new Array(maxValue+1),        sortedIndex = 0;        arrLen = arr.length,        bucketLen = maxValue + 1;    for (var i = 0; i &lt; arrLen; i++) {        if (!bucket[arr[i]]) {            bucket[arr[i]] = 0;        }        bucket[arr[i]]++;    }    for (var j = 0; j &lt; bucketLen; j++) {        while(bucket[j] &gt; 0) {            arr[sortedIndex++] = j;            bucket[j]--;        }    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def countingSort(arr, maxValue):    bucketLen = maxValue+1    bucket = [0]*bucketLen    sortedIndex =0    arrLen = len(arr)    for i in range(arrLen):        if not bucket[arr[i]]:            bucket[arr[i]]=0        bucket[arr[i]]+=1    for j in range(bucketLen):        while bucket[j]&gt;0:            arr[sortedIndex] = j            sortedIndex+=1            bucket[j]-=1    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func countingSort(arr []int, maxValue int) []int {        bucketLen := maxValue + 1        bucket := make([]int, bucketLen) // 初始为0的数组        sortedIndex := 0        length := len(arr)        for i := 0; i &lt; length; i++ {                bucket[arr[i]] += 1        }        for j := 0; j &lt; bucketLen; j++ {                for bucket[j] &gt; 0 {                        arr[sortedIndex] = j                        sortedIndex += 1                        bucket[j] -= 1                }        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class CountingSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int maxValue = getMaxValue(arr);        return countingSort(arr, maxValue);    }    private int[] countingSort(int[] arr, int maxValue) {        int bucketLen = maxValue + 1;        int[] bucket = new int[bucketLen];        for (int value : arr) {            bucket[value]++;        }        int sortedIndex = 0;        for (int j = 0; j &lt; bucketLen; j++) {            while (bucket[j] &gt; 0) {                arr[sortedIndex++] = j;                bucket[j]--;            }        }        return arr;    }    private int getMaxValue(int[] arr) {        int maxValue = arr[0];        for (int value : arr) {            if (maxValue &lt; value) {                maxValue = value;            }        }        return maxValue;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function countingSort($arr, $maxValue = null){    if ($maxValue === null) {        $maxValue = max($arr);    }    for ($m = 0; $m &lt; $maxValue + 1; $m++) {        $bucket[] = null;    }    $arrLen = count($arr);    for ($i = 0; $i &lt; $arrLen; $i++) {        if (!array_key_exists($arr[$i], $bucket)) {            $bucket[$arr[$i]] = 0;        }        $bucket[$arr[$i]]++;    }    $sortedIndex = 0;    foreach ($bucket as $key =&gt; $len) {        if ($len !== null) $arr[$sortedIndex++] = $key;    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;void print_arr(int *arr, int n) {        int i;        printf(&quot;%d&quot;, arr[0]);        for (i = 1; i &lt; n; i++)                printf(&quot; %d&quot;, arr[i]);        printf(&quot;\n&quot;);}void counting_sort(int *ini_arr, int *sorted_arr, int n) {        int *count_arr = (int *) malloc(sizeof(int) * 100);        int i, j, k;        for (k = 0; k &lt; 100; k++)                count_arr[k] = 0;        for (i = 0; i &lt; n; i++)                count_arr[ini_arr[i]]++;        for (k = 1; k &lt; 100; k++)                count_arr[k] += count_arr[k - 1];        for (j = n; j &gt; 0; j--)                sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];        free(count_arr);}int main(int argc, char **argv) {        int n = 10;        int i;        int *arr = (int *) malloc(sizeof(int) * n);        int *sorted_arr = (int *) malloc(sizeof(int) * n);        srand(time(0));        for (i = 0; i &lt; n; i++)                arr[i] = rand() % 100;        printf(&quot;ini_array: &quot;);        print_arr(arr, n);        counting_sort(arr, sorted_arr, n);        printf(&quot;sorted_array: &quot;);        print_arr(sorted_arr, n);        free(arr);        free(sorted_arr);        return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/counting-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/counting-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/posts/b66a.html"/>
      <url>/posts/b66a.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br>    1.大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>    2.小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.创建一个堆 H[0……n-1]；<br>2.把堆首（最大值）和堆尾互换；<br>3.把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>4.重复步骤 2，直到堆的尺寸为 1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/heapSort.gif" alt=""></p><p><img src="img/Sorting_heapsort_anim.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) {   // 建立大顶堆    len = arr.length;    for (var i = Math.floor(len/2); i &gt;= 0; i--) {        heapify(arr, i);    }}function heapify(arr, i) {     // 堆调整    var left = 2 * i + 1,        right = 2 * i + 2,        largest = i;    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {        largest = left;    }    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {        largest = right;    }    if (largest != i) {        swap(arr, i, largest);        heapify(arr, largest);    }}function swap(arr, i, j) {    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}function heapSort(arr) {    buildMaxHeap(arr);    for (var i = arr.length-1; i &gt; 0; i--) {        swap(arr, 0, i);        len--;        heapify(arr, 0);    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def buildMaxHeap(arr):    import math    for i in range(math.floor(len(arr)/2),-1,-1):        heapify(arr,i)def heapify(arr, i):    left = 2*i+1    right = 2*i+2    largest = i    if left &lt; arrLen and arr[left] &gt; arr[largest]:        largest = left    if right &lt; arrLen and arr[right] &gt; arr[largest]:        largest = right    if largest != i:        swap(arr, i, largest)        heapify(arr, largest)def swap(arr, i, j):    arr[i], arr[j] = arr[j], arr[i]def heapSort(arr):    global arrLen    arrLen = len(arr)    buildMaxHeap(arr)    for i in range(len(arr)-1,0,-1):        swap(arr,0,i)        arrLen -=1        heapify(arr, 0)    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func heapSort(arr []int) []int {        arrLen := len(arr)        buildMaxHeap(arr, arrLen)        for i := arrLen - 1; i &gt;= 0; i-- {                swap(arr, 0, i)                arrLen -= 1                heapify(arr, 0, arrLen)        }        return arr}func buildMaxHeap(arr []int, arrLen int) {        for i := arrLen / 2; i &gt;= 0; i-- {                heapify(arr, i, arrLen)        }}func heapify(arr []int, i, arrLen int) {        left := 2*i + 1        right := 2*i + 2        largest := i        if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] {                largest = left        }        if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] {                largest = right        }        if largest != i {                swap(arr, i, largest)                heapify(arr, largest, arrLen)        }}func swap(arr []int, i, j int) {        arr[i], arr[j] = arr[j], arr[i]}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class HeapSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int len = arr.length;        buildMaxHeap(arr, len);        for (int i = len - 1; i &gt; 0; i--) {            swap(arr, 0, i);            len--;            heapify(arr, 0, len);        }        return arr;    }    private void buildMaxHeap(int[] arr, int len) {        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {            heapify(arr, i, len);        }    }    private void heapify(int[] arr, int i, int len) {        int left = 2 * i + 1;        int right = 2 * i + 2;        int largest = i;        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {            largest = left;        }        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {            largest = right;        }        if (largest != i) {            swap(arr, i, largest);            heapify(arr, largest, len);        }    }    private void swap(int[] arr, int i, int j) {        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function buildMaxHeap(&amp;$arr){    global $len;    for ($i = floor($len/2); $i &gt;= 0; $i--) {        heapify($arr, $i);    }}function heapify(&amp;$arr, $i){    global $len;    $left = 2 * $i + 1;    $right = 2 * $i + 2;    $largest = $i;    if ($left &lt; $len &amp;&amp; $arr[$left] &gt; $arr[$largest]) {        $largest = $left;    }    if ($right &lt; $len &amp;&amp; $arr[$right] &gt; $arr[$largest]) {        $largest = $right;    }    if ($largest != $i) {        swap($arr, $i, $largest);        heapify($arr, $largest);    }}function swap(&amp;$arr, $i, $j){    $temp = $arr[$i];    $arr[$i] = $arr[$j];    $arr[$j] = $temp;}function heapSort($arr) {    global $len;    $len = count($arr);    buildMaxHeap($arr);    for ($i = count($arr) - 1; $i &gt; 0; $i--) {        swap($arr, 0, $i);        $len--;        heapify($arr, 0);    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a, int *b) {    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比較            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    int i;    // 初始化，i從最後一個父節點開始調整    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢    for (i = len - 1; i &gt; 0; i--) {        swap(&amp;arr[0], &amp;arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    int i;    for (i = 0; i &lt; len; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);    return 0;}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(int arr[], int start, int end) {    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) { // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else { // 否則交換父子內容再繼續子節點和孫節點比較            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len) {    // 初始化，i從最後一個父節點開始調整    for (int i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢    for (int i = len - 1; i &gt; 0; i--) {        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    }}int main() {    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    for (int i = 0; i &lt; len; i++)        cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;    return 0;}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/7.heapSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/7.heapSort.md</a></em></p><p><a href="https://www.runoob.com/w3cnote/heap-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/heap-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之快速排序</title>
      <link href="/posts/bd38.html"/>
      <url>/posts/bd38.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好<br>    快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。《算法艺术与信息学竞赛》</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.从数列中挑出一个元素，称为“基准”（privot）<br>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的可以任意一边）。在这个分区退出后，该基准就处于数列的中间位置。这个称为分区操作；<br>3.递归地把小于基准值元素地子数列和大于基准值元素的子数列排序；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/quickSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function quickSort(arr, left, right) {    var len = arr.length,        partitionIndex,        left = typeof left != &#39;number&#39; ? 0 : left,        right = typeof right != &#39;number&#39; ? len - 1 : right;    if (left &lt; right) {        partitionIndex = partition(arr, left, right);        quickSort(arr, left, partitionIndex-1);        quickSort(arr, partitionIndex+1, right);    }    return arr;}function partition(arr, left ,right) {     // 分区操作    var pivot = left,                      // 设定基准值（pivot）        index = pivot + 1;    for (var i = index; i &lt;= right; i++) {        if (arr[i] &lt; arr[pivot]) {            swap(arr, i, index);            index++;        }            }    swap(arr, pivot, index - 1);    return index-1;}function swap(arr, i, j) {    var temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}function partition2(arr, low, high) {  let pivot = arr[low];  while (low &lt; high) {    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {      --high;    }    arr[low] = arr[high];    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {      ++low;    }    arr[high] = arr[low];  }  arr[low] = pivot;  return low;}function quickSort2(arr, low, high) {  if (low &lt; high) {    let pivot = partition2(arr, low, high);    quickSort2(arr, low, pivot - 1);    quickSort2(arr, pivot + 1, high);  }  return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def quickSort(arr, left=None, right=None):    left = 0 if not isinstance(left,(int, float)) else left    right = len(arr)-1 if not isinstance(right,(int, float)) else right    if left &lt; right:        partitionIndex = partition(arr, left, right)        quickSort(arr, left, partitionIndex-1)        quickSort(arr, partitionIndex+1, right)    return arrdef partition(arr, left, right):    pivot = left    index = pivot+1    i = index    while  i &lt;= right:        if arr[i] &lt; arr[pivot]:            swap(arr, i, index)            index+=1        i+=1    swap(arr,pivot,index-1)    return index-1def swap(arr, i, j):    arr[i], arr[j] = arr[j], arr[i]</code></pre><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><pre><code>func quickSort(arr []int) []int {        return _quickSort(arr, 0, len(arr)-1)}func _quickSort(arr []int, left, right int) []int {        if left &lt; right {                partitionIndex := partition(arr, left, right)                _quickSort(arr, left, partitionIndex-1)                _quickSort(arr, partitionIndex+1, right)        }        return arr}func partition(arr []int, left, right int) int {        pivot := left        index := pivot + 1        for i := index; i &lt;= right; i++ {                if arr[i] &lt; arr[pivot] {                        swap(arr, i, index)                        index += 1                }        }        swap(arr, pivot, index-1)        return index - 1}func swap(arr []int, i, j int) {        arr[i], arr[j] = arr[j], arr[i]}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>//严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) {   int pivot = A[low];   while (low &lt; high) {     while (low &lt; high &amp;&amp; A[high] &gt;= pivot) {       --high;     }     A[low] = A[high];     while (low &lt; high &amp;&amp; A[low] &lt;= pivot) {       ++low;     }     A[high] = A[low];   }   A[low] = pivot;   return low; } void QuickSort(int A[], int low, int high) //快排母函数 {   if (low &lt; high) {     int pivot = Paritition1(A, low, high);     QuickSort(A, low, pivot - 1);     QuickSort(A, pivot + 1, high);   } }</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class QuickSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        return quickSort(arr, 0, arr.length - 1);    }    private int[] quickSort(int[] arr, int left, int right) {        if (left &lt; right) {            int partitionIndex = partition(arr, left, right);            quickSort(arr, left, partitionIndex - 1);            quickSort(arr, partitionIndex + 1, right);        }        return arr;    }    private int partition(int[] arr, int left, int right) {        // 设定基准值（pivot）        int pivot = left;        int index = pivot + 1;        for (int i = index; i &lt;= right; i++) {            if (arr[i] &lt; arr[pivot]) {                swap(arr, i, index);                index++;            }        }        swap(arr, pivot, index - 1);        return index - 1;    }    private void swap(int[] arr, int i, int j) {        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function quickSort($arr){    if (count($arr) &lt;= 1)        return $arr;    $middle = $arr[0];    $leftArray = array();    $rightArray = array();    for ($i = 1; $i &lt; count($arr); $i++) {        if ($arr[$i] &gt; $middle)            $rightArray[] = $arr[$i];        else            $leftArray[] = $arr[$i];    }    $leftArray = quickSort($leftArray);    $leftArray[] = $middle;    $rightArray = quickSort($rightArray);    return array_merge($leftArray, $rightArray);}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><pre><code>typedef struct _Range {    int start, end;} Range;Range new_Range(int s, int e) {    Range r;    r.start = s;    r.end = e;    return r;}void swap(int *x, int *y) {    int t = *x;    *x = *y;    *y = t;}void quick_sort(int arr[], const int len) {    if (len &lt;= 0)        return; // 避免len等於負值時引發段錯誤（Segment Fault）    // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素    Range r[len];    int p = 0;    r[p++] = new_Range(0, len - 1);    while (p) {        Range range = r[--p];        if (range.start &gt;= range.end)            continue;        int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點        int left = range.start, right = range.end;        do {            while (arr[left] &lt; mid) ++left;   // 檢測基準點左側是否符合要求            while (arr[right] &gt; mid) --right; //檢測基準點右側是否符合要求            if (left &lt;= right) {                swap(&amp;arr[left], &amp;arr[right]);                left++;                right--;               // 移動指針以繼續            }        } while (left &lt;= right);        if (range.start &lt; right) r[p++] = new_Range(range.start, right);        if (range.end &gt; left) r[p++] = new_Range(left, range.end);    }}</code></pre><p>递归版：</p><pre><code>void swap(int *x, int *y) {    int t = *x;    *x = *y;    *y = t;}void quick_sort_recursive(int arr[], int start, int end) {    if (start &gt;= end)        return;    int mid = arr[end];    int left = start, right = end - 1;    while (left &lt; right) {        while (arr[left] &lt; mid &amp;&amp; left &lt; right)            left++;        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)            right--;        swap(&amp;arr[left], &amp;arr[right]);    }    if (arr[left] &gt;= arr[end])        swap(&amp;arr[left], &amp;arr[end]);    else        left++;    if (left)        quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);}void quick_sort(int arr[], int len) {    quick_sort_recursive(arr, 0, len - 1);}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><p>函数版：</p><pre><code>sort(a,a + n);// 排序a[0]-a[n-1]的所有数.</code></pre><p>递归版：</p><pre><code>template &lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) {    if (start &gt;= end)        return;    T mid = arr[end];    int left = start, right = end - 1;    while (left &lt; right) { //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换        while (arr[left] &lt; mid &amp;&amp; left &lt; right) //试图在左侧找到一个比枢纽元更大的元素            left++;        while (arr[right] &gt;= mid &amp;&amp; left &lt; right) //试图在右侧找到一个比枢纽元更小的元素            right--;        std::swap(arr[left], arr[right]); //交换元素    }    if (arr[left] &gt;= arr[end])        std::swap(arr[left], arr[end]);    else        left++;    quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);}template &lt;typename T&gt; //整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能void quick_sort(T arr[], int len) {    quick_sort_recursive(arr, 0, len - 1);}</code></pre><p>迭代版：</p><pre><code>// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/struct Range {    int start, end;    Range(int s = 0, int e = 0) {        start = s, end = e;    }};template &lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能void quick_sort(T arr[], const int len) {    if (len &lt;= 0)        return; // 避免len等於負值時宣告堆疊陣列當機    // r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素    Range r[len];    int p = 0;    r[p++] = Range(0, len - 1);    while (p) {        Range range = r[--p];        if (range.start &gt;= range.end)            continue;        T mid = arr[range.end];        int left = range.start, right = range.end - 1;        while (left &lt; right) {            while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;            while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;            std::swap(arr[left], arr[right]);        }        if (arr[left] &gt;= arr[range.end])            std::swap(arr[left], arr[range.end]);        else            left++;        r[p++] = Range(range.start, left - 1);        r[p++] = Range(left + 1, range.end);    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</a></p><p><a href="https://www.runoob.com/w3cnote/quick-sort-2.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/quick-sort-2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之归并排序</title>
      <link href="/posts/69cd.html"/>
      <url>/posts/69cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。<br>该算法是采用分治法。<br>作为一种典型的分而治之的算法，归并排序的实现有两种方法：<br>    自上而下的递归（由于所有的递归方法都可以用迭代重写，所以还有第二种方法）<br>    自下而上的迭代；<br>PS：递归虽然有简洁的优点，但是也有显著的缺点：<br>    1.时间、空间方面：由于递归是函数调用自身，而函数调用是有时间和空间的消耗的，每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而且往栈中压入数据和弹出数据都需要时间。<br>    2.效率方面：递归中很多计算都是重复的，从而性能带来很大的负面影响。递归的本质是把一个问题分解成两个或多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。<br>    3.调用栈溢出：递归每调用一次函数都需要为函数在内存栈中分配空间，而每一个进程的栈容量是有限的。当递归调用的层次太多时，就会超出栈的容量，从而导致调用栈溢出。如求 1+2+3+4+….+n的和，如果n为10，结果可以返回，但如果n为5000，那么得出来的结果就会出错。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后得序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择较小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤3直到某一指针达到序列尾；<br>5.将另一序列剩下的所有元素直接复制到合并序列列尾。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="img/mergeSort.gif" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function mergeSort(arr) {  // 采用自上而下的递归方法    var len = arr.length;    if(len &lt; 2) {        return arr;    }    var middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));}function merge(left, right){    var result = [];    while (left.length &amp;&amp; right.length) {        if (left[0] &lt;= right[0]) {            result.push(left.shift());        } else {            result.push(right.shift());        }    }    while (left.length)        result.push(left.shift());    while (right.length)        result.push(right.shift());    return result;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def mergeSort(arr):    import math    if(len(arr)&lt;2):        return arr    middle = math.floor(len(arr)/2)    left, right = arr[0:middle], arr[middle:]    return merge(mergeSort(left), mergeSort(right))def merge(left,right):    result = []    while left and right:        if left[0] &lt;= right[0]:            result.append(left.pop(0))        else:            result.append(right.pop(0));    while left:        result.append(left.pop(0))    while right:        result.append(right.pop(0));    return result</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func mergeSort(arr []int) []int {        length := len(arr)        if length &lt; 2 {                return arr        }        middle := length / 2        left := arr[0:middle]        right := arr[middle:]        return merge(mergeSort(left), mergeSort(right))}func merge(left []int, right []int) []int {        var result []int        for len(left) != 0 &amp;&amp; len(right) != 0 {                if left[0] &lt;= right[0] {                        result = append(result, left[0])                        left = left[1:]                } else {                        result = append(result, right[0])                        right = right[1:]                }        }        for len(left) != 0 {                result = append(result, left[0])                left = left[1:]        }        for len(right) != 0 {                result = append(result, right[0])                right = right[1:]        }        return result}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class MergeSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        if (arr.length &lt; 2) {            return arr;        }        int middle = (int) Math.floor(arr.length / 2);        int[] left = Arrays.copyOfRange(arr, 0, middle);        int[] right = Arrays.copyOfRange(arr, middle, arr.length);        return merge(sort(left), sort(right));    }    protected int[] merge(int[] left, int[] right) {        int[] result = new int[left.length + right.length];        int i = 0;        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {            if (left[0] &lt;= right[0]) {                result[i++] = left[0];                left = Arrays.copyOfRange(left, 1, left.length);            } else {                result[i++] = right[0];                right = Arrays.copyOfRange(right, 1, right.length);            }        }        while (left.length &gt; 0) {            result[i++] = left[0];            left = Arrays.copyOfRange(left, 1, left.length);        }        while (right.length &gt; 0) {            result[i++] = right[0];            right = Arrays.copyOfRange(right, 1, right.length);        }        return result;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function mergeSort($arr){    $len = count($arr);    if ($len &lt; 2) {        return $arr;    }    $middle = floor($len / 2);    $left = array_slice($arr, 0, $middle);    $right = array_slice($arr, $middle);    return merge(mergeSort($left), mergeSort($right));}function merge($left, $right){    $result = [];    while (count($left) &gt; 0 &amp;&amp; count($right) &gt; 0) {        if ($left[0] &lt;= $right[0]) {            $result[] = array_shift($left);        } else {            $result[] = array_shift($right);        }    }    while (count($left))        $result[] = array_shift($left);    while (count($right))        $result[] = array_shift($right);    return $result;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>int min(int x, int y) {    return x &lt; y ? x : y;}void merge_sort(int arr[], int len) {    int *a = arr;    int *b = (int *) malloc(len * sizeof(int));    int seg, start;    for (seg = 1; seg &lt; len; seg += seg) {        for (start = 0; start &lt; len; start += seg * 2) {            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        int *temp = a;        a = b;        b = temp;    }    if (a != arr) {        int i;        for (i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    free(b);}</code></pre><p>递归版：</p><pre><code>void merge_sort_recursive(int arr[], int reg[], int start, int end) {    if (start &gt;= end)        return;    int len = end - start, mid = (len &gt;&gt; 1) + start;    int start1 = start, end1 = mid;    int start2 = mid + 1, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    int k = start;    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    while (start1 &lt;= end1)        reg[k++] = arr[start1++];    while (start2 &lt;= end2)        reg[k++] = arr[start2++];    for (k = start; k &lt;= end; k++)        arr[k] = reg[k];}void merge_sort(int arr[], const int len) {    int reg[len];    merge_sort_recursive(arr, reg, 0, len - 1);}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>迭代版：</p><pre><code>template&lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能void merge_sort(T arr[], int len) {    T *a = arr;    T *b = new T[len];    for (int seg = 1; seg &lt; len; seg += seg) {        for (int start = 0; start &lt; len; start += seg + seg) {            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        }        T *temp = a;        a = b;        b = temp;    }    if (a != arr) {        for (int i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    }    delete[] b;}</code></pre><p>递归版：</p><pre><code>void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) {    // preconditions:    // Array[front...mid] is sorted    // Array[mid+1 ... end] is sorted    // Copy Array[front ... mid] to LeftSubArray    // Copy Array[mid+1 ... end] to RightSubArray    vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);    vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);    int idxLeft = 0, idxRight = 0;    LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max());    RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max());    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]    for (int i = front; i &lt;= end; i++) {        if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) {            Array[i] = LeftSubArray[idxLeft];            idxLeft++;        } else {            Array[i] = RightSubArray[idxRight];            idxRight++;        }    }}void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) {    if (front &gt;= end)        return;    int mid = (front + end) / 2;    MergeSort(Array, front, mid);    MergeSort(Array, mid + 1, end);    Merge(Array, front, mid, end);}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><pre><code>public static List&lt;int&gt; sort(List&lt;int&gt; lst) {    if (lst.Count &lt;= 1)        return lst;    int mid = lst.Count / 2;    List&lt;int&gt; left = new List&lt;int&gt;();  // 定义左侧List    List&lt;int&gt; right = new List&lt;int&gt;(); // 定义右侧List    // 以下兩個循環把 lst 分為左右兩個 List    for (int i = 0; i &lt; mid; i++)        left.Add(lst[i]);    for (int j = mid; j &lt; lst.Count; j++)        right.Add(lst[j]);    left = sort(left);    right = sort(right);    return merge(left, right);}/// &lt;summary&gt;/// 合併兩個已經排好序的List/// &lt;/summary&gt;/// &lt;param name=&quot;left&quot;&gt;左側List&lt;/param&gt;/// &lt;param name=&quot;right&quot;&gt;右側List&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static List&lt;int&gt; merge(List&lt;int&gt; left, List&lt;int&gt; right) {    List&lt;int&gt; temp = new List&lt;int&gt;();    while (left.Count &gt; 0 &amp;&amp; right.Count &gt; 0) {        if (left[0] &lt;= right[0]) {            temp.Add(left[0]);            left.RemoveAt(0);        } else {            temp.Add(right[0]);            right.RemoveAt(0);        }    }    if (left.Count &gt; 0) {        for (int i = 0; i &lt; left.Count; i++)            temp.Add(left[i]);    }    if (right.Count &gt; 0) {        for (int i = 0; i &lt; right.Count; i++)            temp.Add(right[i]);    }    return temp;}</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><pre><code>def merge list  return list if list.size &lt; 2  pivot = list.size / 2  # Merge  lambda { |left, right|    final = []    until left.empty? or right.empty?      final &lt;&lt; if left.first &lt; right.first; left.shift else right.shift end    end    final + left + right  }.call merge(list[0...pivot]), merge(list[pivot..-1])end</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F</a></p><p><a href="https://www.runoob.com/w3cnote/merge-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/merge-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序之希尔排序</title>
      <link href="/posts/75c9.html"/>
      <url>/posts/75c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>希尔排序，也称为递减增量排序，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>    插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>    但插入排序一般来说是低效的，因为插入排序每一次只能将数据移动一位。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>选择一个增量序列t1，t2，t3…..,tk，其中ti&gt;tj，tk=1 ；<br>按增量序列个数k，对序列进行k趟排序；<br>每趟排序，根据对应的增量ti，将待排序分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function shellSort(arr) {    var len = arr.length,        temp,        gap = 1;    while(gap &lt; len/3) {          //动态定义间隔序列        gap =gap*3+1;    }    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {        for (var i = gap; i &lt; len; i++) {            temp = arr[i];            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {                arr[j+gap] = arr[j];            }            arr[j+gap] = temp;        }    }    return arr;}</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>def shellSort(arr):    import math    gap=1    while(gap &lt; len(arr)/3):        gap = gap*3+1    while gap &gt; 0:        for i in range(gap,len(arr)):            temp = arr[i]            j = i-gap            while j &gt;=0 and arr[j] &gt; temp:                arr[j+gap]=arr[j]                j-=gap            arr[j+gap] = temp        gap = math.floor(gap/3)    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func shellSort(arr []int) []int {        length := len(arr)        gap := 1        for gap &lt; gap/3 {                gap = gap*3 + 1        }        for gap &gt; 0 {                for i := gap; i &lt; length; i++ {                        temp := arr[i]                        j := i - gap                        for j &gt;= 0 &amp;&amp; arr[j] &gt; temp {                                arr[j+gap] = arr[j]                                j -= gap                        }                        arr[j+gap] = temp                }                gap = gap / 3        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class ShellSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        int gap = 1;        while (gap &lt; arr.length) {            gap = gap * 3 + 1;        }        while (gap &gt; 0) {            for (int i = gap; i &lt; arr.length; i++) {                int tmp = arr[i];                int j = i - gap;                while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {                    arr[j + gap] = arr[j];                    j -= gap;                }                arr[j + gap] = tmp;            }            gap = (int) Math.floor(gap / 3);        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function shellSort($arr){    $len = count($arr);    $temp = 0;    $gap = 1;    while($gap &lt; $len / 3) {        $gap = $gap * 3 + 1;    }    for ($gap; $gap &gt; 0; $gap = floor($gap / 3)) {        for ($i = $gap; $i &lt; $len; $i++) {            $temp = $arr[$i];            for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $temp; $j -= $gap) {                $arr[$j+$gap] = $arr[$j];            }            $arr[$j+$gap] = $temp;        }    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>void shell_sort(int arr[], int len) {        int gap, i, j;        int temp;        for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)                for (i = gap; i &lt; len; i++) {                        temp = arr[i];                        for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                                arr[j + gap] = arr[j];                        arr[j + gap] = temp;                }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>template&lt;typename T&gt;void shell_sort(T array[], int length) {    int h = 1;    while (h &lt; length / 3) {        h = 3 * h + 1;    }    while (h &gt;= 1) {        for (int i = h; i &lt; length; i++) {            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {                std::swap(array[j], array[j - h]);            }        }        h = h / 3;    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/4.shellSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/4.shellSort.md</a></p><p><a href="https://www.runoob.com/w3cnote/shell-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/shell-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之插入排序</title>
      <link href="/posts/551c.html"/>
      <url>/posts/551c.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>插入排序是一种最简单直观的排序算法，工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序和冒泡排序一样，也有一种优化算法，叫折半插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>将第一排待排序序列第一个元素看作一个有序序列，把第二个元素到最后一个元素当作是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每一个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某一个元素相等，则将待插入元素插到相等元素的后面）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> preIndex<span class="token punctuation">,</span> current<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            preIndex<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">while</span> preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>            preIndex<span class="token operator">-=</span><span class="token number">1</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current    <span class="token keyword">return</span> arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func insertionSort(arr []int) []int {        for i := range arr {                preIndex := i - 1                current := arr[i]                for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {                        arr[preIndex+1] = arr[preIndex]                        preIndex -= 1                }                arr[preIndex+1] = current        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class InsertSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        // 对 arr 进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的        for (int i = 1; i &lt; arr.length; i++) {            // 记录要插入的数据            int tmp = arr[i];            // 从已经排序的序列最右边的开始比较，找到比其小的数            int j = i;            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) {                arr[j] = arr[j - 1];                j--;            }            // 存在比其小的数，插入            if (j != i) {                arr[j] = tmp;            }        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function insertionSort($arr){    $len = count($arr);    for ($i = 1; $i &lt; $len; $i++) {        $preIndex = $i - 1;        $current = $arr[$i];        while($preIndex &gt;= 0 &amp;&amp; $arr[$preIndex] &gt; $current) {            $arr[$preIndex+1] = $arr[$preIndex];            $preIndex--;        }        $arr[$preIndex+1] = $current;    }    return $arr;}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre><code>void insertion_sort(int arr[], int len){        int i,j,key;        for (i=1;i&lt;len;i++){                key = arr[i];                j=i-1;                while((j&gt;=0) &amp;&amp; (arr[j]&gt;key)) {                        arr[j+1] = arr[j];                        j--;                }                arr[j+1] = key;        }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><pre><code>void insertion_sort(int arr[],int len){        for(int i=1;i&lt;len;i++){                int key=arr[i];                int j=i-1;                while((j&gt;=0) &amp;&amp; (key&lt;arr[j])){                        arr[j+1]=arr[j];                        j--;                }                arr[j+1]=key;        }}</code></pre><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><pre><code>public static void InsertSort(int[] array){    for(int i = 1;i &lt; array.length;i++)    {        int temp = array[i];        for(int j = i - 1;j &gt;= 0;j--)        {            if(array[j] &gt; temp)            {                array[j + 1] = array[j];                array[j] = temp;            }            else                break;        }    }}</code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre><code>for i in 1..&lt;arr.endIndex {    let temp = arr[i]    for j in (0..&lt;i).reversed() {        if arr[j] &gt; temp {            arr.swapAt(j, j+1)        }    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/w3cnote/insertion-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/insertion-sort.html</a><br><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/3.insertionSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/3.insertionSort.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之选择排序</title>
      <link href="/posts/5911.html"/>
      <url>/posts/5911.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去，都是 O(n²)的时间复杂度。所以用到选择排序的时候，数据规模越小越好。</p><p>选择排序唯一的好处可能就是不占用额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>首先在未排序的序列中找到最小（大）的元素，存放在排序序列的起始位置。</p><p>再从剩余未排序的序列的中继续寻找最小（大）的元素，然后存放在已排序序列的末尾。</p><p>重复第二步操作，直到所有元素均排序完毕。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre><code>function selectionSort(arr) {    var len = arr.length;    var minIndex, temp;    for (var i = 0; i &lt; len - 1; i++) {        minIndex = i;        for (var j = i + 1; j &lt; len; j++) {            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数                minIndex = j;                 // 将最小数的索引保存            }        }        temp = arr[i];        arr[i] = arr[minIndex];        arr[minIndex] = temp;    }    return arr;}</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code>def selectionSort(arr):    for i in range(len(arr) - 1):        # 记录最小数的索引        minIndex = i        for j in range(i + 1, len(arr)):            if arr[j] &lt; arr[minIndex]:                minIndex = j        # i 不是最小数时，将 i 和最小数进行交换        if i != minIndex:            arr[i], arr[minIndex] = arr[minIndex], arr[i]    return arr</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><pre><code>func selectionSort(arr []int) []int {        length := len(arr)        for i := 0; i &lt; length-1; i++ {                min := i                for j := i + 1; j &lt; length; j++ {                        if arr[min] &gt; arr[j] {                                min = j                        }                }                arr[i], arr[min] = arr[min], arr[i]        }        return arr}</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code>public class SelectionSort implements IArraySort {    @Override    public int[] sort(int[] sourceArray) throws Exception {        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);        // 总共要经过 N-1 轮比较        for (int i = 0; i &lt; arr.length - 1; i++) {            int min = i;            // 每轮需要比较的次数 N-i            for (int j = i + 1; j &lt; arr.length; j++) {                if (arr[j] &lt; arr[min]) {                    // 记录目前能找到的最小值元素的下标                    min = j;                }            }            // 将找到的最小值和i位置所在的值进行交换            if (i != min) {                int tmp = arr[i];                arr[i] = arr[min];                arr[min] = tmp;            }        }        return arr;    }}</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code>function selectionSort($arr){    $len = count($arr);    for ($i = 0; $i &lt; $len - 1; $i++) {        $minIndex = $i;        for ($j = $i + 1; $j &lt; $len; $j++) {            if ($arr[$j] &lt; $arr[$minIndex]) {                $minIndex = $j;            }        }        $temp = $arr[$i];        $arr[$i] = $arr[$minIndex];        $arr[$minIndex] = $temp;    }    return $arr;}</code></pre><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><pre><code>void swap(int *a,int *b) //交換兩個變數{    int temp = *a;    *a = *b;    *b = temp;}void selection_sort(int arr[], int len){    int i,j;        for (i = 0 ; i &lt; len - 1 ; i++)    {                int min = i;                for (j = i + 1; j &lt; len; j++)     //走訪未排序的元素                        if (arr[j] &lt; arr[min])    //找到目前最小值                                min = j;    //紀錄最小值                swap(&amp;arr[min], &amp;arr[i]);    //做交換        }}</code></pre><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre><code>template&lt;typename T&gt; //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能void selection_sort(std::vector&lt;T&gt;&amp; arr) {        for (int i = 0; i &lt; arr.size() - 1; i++) {                int min = i;                for (int j = i + 1; j &lt; arr.size(); j++)                        if (arr[j] &lt; arr[min])                                min = j;                std::swap(arr[i], arr[min]);        }}</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><pre><code>static void selection_sort&lt;T&gt;(T[] arr) where T : System.IComparable&lt;T&gt;{//整數或浮點數皆可使用        int i, j, min, len = arr.Length;        T temp;        for (i = 0; i &lt; len - 1; i++) {                min = i;                for (j = i + 1; j &lt; len; j++)                        if (arr[min].CompareTo(arr[j]) &gt; 0)                                min = j;                temp = arr[min];                arr[min] = arr[i];                arr[i] = temp;        }}</code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre><code>import Foundation/// 选择排序////// - Parameter list: 需要排序的数组func selectionSort(_ list: inout [Int]) -&gt; Void {    for j in 0..&lt;list.count - 1 {        var minIndex = j        for i in j..&lt;list.count {            if list[minIndex] &gt; list[i] {                minIndex = i            }        }        list.swapAt(j, minIndex)    }}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/2.selectionSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/2.selectionSort.md</a><br><a href="https://www.runoob.com/w3cnote/selection-sort.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/selection-sort.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言初探—sizeof(数组名)与sizeof(*数组名)</title>
      <link href="/posts/197e.html"/>
      <url>/posts/197e.html</url>
      
        <content type="html"><![CDATA[<pre><code>#include&lt;stdio.h&gt;int main(){    int a[5]={1,2,3,4,5};    int len=(int)sizeof(a)/sizeof(*a);    printf(&quot;sizeof(数组名)=%d\n&quot;,sizeof(a));    printf(&quot;sizeof(*数组名)=%d\n&quot;,sizeof(*a));    printf(&quot;%d\n,len);    return 0;}</code></pre><p>运行结果：<br>sizeof(数组名)=20<br>sizeof(<em>数组名)=4<br>5<br>分析：<br>a为含有5个元素的数组，<br>数组名代表元素的首地址，所以sizeof(a)代表整个数组所占的内存空间，即5</em>4Byte=20Byte；<br><em>a表示指向首地址，即表示首地址的内容，所以sizeof(</em>a)表示首元素所占空间的大小。<br>(int)sizeof(a)/siezof(*a)表示的是数组a中所包含的元素个数。</p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法之冒泡排序</title>
      <link href="/posts/c3e4.html"/>
      <url>/posts/c3e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地访问要排序地数列，一次比较两个元素，如果两个元素的排序顺序错误，就把他们交换过来。直到数列的排序顺序正确后就停止走访。这个算法的名字的由来是因为越小的元素会经过交换而慢慢浮到数列的顶端。</p><h2 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1.算法步骤"></a>1.算法步骤</h2><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一队到结尾的最后一对。这一步操作做完后，最后的元素就会是最大的数。<br>针对所有的元素重复上述步骤，除了最后一个元素。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><p><img src="F:%5Cblog2%5Csource%5Cimg%5CbubbleSort.gif" alt=""></p><h2 id="3-最快与最慢"><a href="#3-最快与最慢" class="headerlink" title="3.最快与最慢"></a>3.最快与最慢</h2><p>当输入的数据已经是正序时，排序速度最快。<br>当输入的数据是反序时，排序速度最慢。</p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 相邻元素两两对比</span>                <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 元素交换</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>        length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">70</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">func</span> <span class="token function">bubbleSort</span> <span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>arr<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>arr<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i <span class="token punctuation">{</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试调用</span><span class="token keyword">func</span> <span class="token function">testSort</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 生成随机数数组进行排序操作</span>    <span class="token keyword">var</span> list<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token number">_</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">99</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token function">arc4random_uniform</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>list<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>list<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md</a></p><p><img src="C:%5CUsers%5CWillis-zzx%5CPictures%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5Ca4a3280e72d249caa75234ed749daedd.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+hexo搭建个人博客(主题：yilia)</title>
      <link href="/posts/b2ba.html"/>
      <url>/posts/b2ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>总结一下这一次的博客搭建吧，把所有步骤都写下来。</p><p>hexo是一个静态网页博客，很容易上手，在本地端部署后，再git到GitHub上，其余的域名什么的都不用搭理，这个比之前的wordprss容易多了，wordpress是动态博客，比较难。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h2 id="1-安装Node-js和hexo框架"><a href="#1-安装Node-js和hexo框架" class="headerlink" title="1.安装Node.js和hexo框架"></a>1.安装Node.js和hexo框架</h2><p>在官网就可以下载，最好下载新版的。</p><p>打开终端命令行，我的是win10，用powershell，在vs code新建终端即可。</p><p>node -v #查看node版本</p><p>npm -v #查看npm版本</p><p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a> #安装淘宝的cnpm 管理器</p><p>cnpm -v #查看cnpm版本</p><p>ps:我没安装cnpm，安装这个一直不成功，直接用npm安装hexo也挺快的。</p><p>cnpm install -g hexo-cli #安装hexo框架</p><p>hexo -v #查看hexo版本</p><h2 id="2-创建博客"><a href="#2-创建博客" class="headerlink" title="2.创建博客"></a>2.创建博客</h2><p>mkdri blog #创建blog目录</p><p>cd blog #进入blog目录</p><p>hexo init #生成博客，初始化博客</p><p>hexo s #启动本地博客服务</p><p><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> #本地访问地址</p><p>hexo n “我的第一篇文章” #创建新的文章</p><p>cd /.. #返回blog目录</p><p>hexo clean #清理</p><p>hexo g #生成</p><h2 id="3-构建GitHub仓库"><a href="#3-构建GitHub仓库" class="headerlink" title="3.构建GitHub仓库"></a>3.构建GitHub仓库</h2><p>在自己的GitHub账号中创建一个仓库YourGithubName.github.io</p><p>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><p>#配置blog根目录下的_config.yaml文件</p><p>deploy:<br>  type: git<br>  repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>  branch: master</p><p>hexo d #部署到Github仓库里</p><p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>返回blog目录</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo clean #清理</p><p>hexo g #生成</p><p>hexo d #部署到远端GitHub仓库</p><p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #查看博客</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
